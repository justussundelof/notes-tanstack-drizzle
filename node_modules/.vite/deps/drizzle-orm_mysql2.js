import {
  require_caching_sha2_password,
  require_charset_encodings,
  require_charsets,
  require_connection,
  require_connection_config,
  require_create_connection,
  require_create_pool,
  require_create_pool_cluster,
  require_events,
  require_mysql_clear_password,
  require_mysql_native_password,
  require_net,
  require_parser_cache,
  require_pool,
  require_pool_cluster,
  require_pool_connection,
  require_promise,
  require_sha256_password,
  require_sqlstring,
  require_types
} from "./chunk-ZJSPGQF2.js";
import {
  MySqlDatabase,
  MySqlDialect,
  MySqlPreparedQuery,
  MySqlSession,
  MySqlTransaction,
  NoopCache
} from "./chunk-I2HCTNL4.js";
import {
  Column,
  DefaultLogger,
  DrizzleError,
  NoopLogger,
  createTableRelationsHelpers,
  entityKind,
  extractTablesRelationalConfig,
  fillPlaceholders,
  is,
  isConfig,
  mapResultRow,
  sql
} from "./chunk-K5WNBFCQ.js";
import {
  __commonJS,
  __toESM
} from "./chunk-7D4SUZUM.js";

// node_modules/mysql2/lib/server.js
var require_server = __commonJS({
  "node_modules/mysql2/lib/server.js"(exports, module) {
    "use strict";
    var net = require_net();
    var EventEmitter = require_events().EventEmitter;
    var Connection = require_connection();
    var ConnectionConfig = require_connection_config();
    var Server = class extends EventEmitter {
      constructor() {
        super();
        this.connections = [];
        this._server = net.createServer(this._handleConnection.bind(this));
      }
      _handleConnection(socket) {
        const connectionConfig = new ConnectionConfig({
          stream: socket,
          isServer: true
        });
        const connection = new Connection({ config: connectionConfig });
        this.emit("connection", connection);
      }
      listen(port) {
        this._port = port;
        this._server.listen.apply(this._server, arguments);
        return this;
      }
      close(cb) {
        this._server.close(cb);
      }
    };
    module.exports = Server;
  }
});

// node_modules/mysql2/lib/auth_plugins/index.js
var require_auth_plugins = __commonJS({
  "node_modules/mysql2/lib/auth_plugins/index.js"(exports, module) {
    "use strict";
    module.exports = {
      caching_sha2_password: require_caching_sha2_password(),
      mysql_clear_password: require_mysql_clear_password(),
      mysql_native_password: require_mysql_native_password(),
      sha256_password: require_sha256_password()
    };
  }
});

// node_modules/mysql2/index.js
var require_mysql2 = __commonJS({
  "node_modules/mysql2/index.js"(exports) {
    "use strict";
    var SqlString = require_sqlstring();
    var ConnectionConfig = require_connection_config();
    var parserCache = require_parser_cache();
    var Connection = require_connection();
    exports.createConnection = require_create_connection();
    exports.connect = exports.createConnection;
    exports.Connection = Connection;
    exports.ConnectionConfig = ConnectionConfig;
    var Pool = require_pool();
    var PoolCluster = require_pool_cluster();
    var createPool2 = require_create_pool();
    var createPoolCluster = require_create_pool_cluster();
    exports.createPool = createPool2;
    exports.createPoolCluster = createPoolCluster;
    exports.createQuery = Connection.createQuery;
    exports.Pool = Pool;
    exports.PoolCluster = PoolCluster;
    exports.createServer = function(handler) {
      const Server = require_server();
      const s = new Server();
      if (handler) {
        s.on("connection", handler);
      }
      return s;
    };
    exports.PoolConnection = require_pool_connection();
    exports.authPlugins = require_auth_plugins();
    exports.escape = SqlString.escape;
    exports.escapeId = SqlString.escapeId;
    exports.format = SqlString.format;
    exports.raw = SqlString.raw;
    exports.__defineGetter__(
      "createConnectionPromise",
      () => require_promise().createConnection
    );
    exports.__defineGetter__(
      "createPoolPromise",
      () => require_promise().createPool
    );
    exports.__defineGetter__(
      "createPoolClusterPromise",
      () => require_promise().createPoolCluster
    );
    exports.__defineGetter__("Types", () => require_types());
    exports.__defineGetter__(
      "Charsets",
      () => require_charsets()
    );
    exports.__defineGetter__(
      "CharsetToEncoding",
      () => require_charset_encodings()
    );
    exports.setMaxParserCache = function(max) {
      parserCache.setMaxCache(max);
    };
    exports.clearParserCache = function() {
      parserCache.clearCache();
    };
  }
});

// browser-external:node:events
var require_node_events = __commonJS({
  "browser-external:node:events"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:events" has been externalized for browser compatibility. Cannot access "node:events.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/drizzle-orm/mysql2/driver.js
var import_mysql2 = __toESM(require_mysql2(), 1);

// node_modules/drizzle-orm/mysql2/session.js
var import_node_events = __toESM(require_node_events(), 1);
var MySql2PreparedQuery = class extends MySqlPreparedQuery {
  constructor(client, queryString, params, logger, cache, queryMetadata, cacheConfig, fields, customResultMapper, generatedIds, returningIds) {
    super(cache, queryMetadata, cacheConfig);
    this.client = client;
    this.params = params;
    this.logger = logger;
    this.fields = fields;
    this.customResultMapper = customResultMapper;
    this.generatedIds = generatedIds;
    this.returningIds = returningIds;
    this.rawQuery = {
      sql: queryString,
      // rowsAsArray: true,
      typeCast: function(field, next) {
        if (field.type === "TIMESTAMP" || field.type === "DATETIME" || field.type === "DATE") {
          return field.string();
        }
        return next();
      }
    };
    this.query = {
      sql: queryString,
      rowsAsArray: true,
      typeCast: function(field, next) {
        if (field.type === "TIMESTAMP" || field.type === "DATETIME" || field.type === "DATE") {
          return field.string();
        }
        return next();
      }
    };
  }
  static [entityKind] = "MySql2PreparedQuery";
  rawQuery;
  query;
  async execute(placeholderValues = {}) {
    const params = fillPlaceholders(this.params, placeholderValues);
    this.logger.logQuery(this.rawQuery.sql, params);
    const { fields, client, rawQuery, query, joinsNotNullableMap, customResultMapper, returningIds, generatedIds } = this;
    if (!fields && !customResultMapper) {
      const res = await this.queryWithCache(rawQuery.sql, params, async () => {
        return await client.query(rawQuery, params);
      });
      const insertId = res[0].insertId;
      const affectedRows = res[0].affectedRows;
      if (returningIds) {
        const returningResponse = [];
        let j = 0;
        for (let i = insertId; i < insertId + affectedRows; i++) {
          for (const column of returningIds) {
            const key = returningIds[0].path[0];
            if (is(column.field, Column)) {
              if (column.field.primary && column.field.autoIncrement) {
                returningResponse.push({ [key]: i });
              }
              if (column.field.defaultFn && generatedIds) {
                returningResponse.push({ [key]: generatedIds[j][key] });
              }
            }
          }
          j++;
        }
        return returningResponse;
      }
      return res;
    }
    const result = await this.queryWithCache(query.sql, params, async () => {
      return await client.query(query, params);
    });
    const rows = result[0];
    if (customResultMapper) {
      return customResultMapper(rows);
    }
    return rows.map((row) => mapResultRow(fields, row, joinsNotNullableMap));
  }
  async *iterator(placeholderValues = {}) {
    const params = fillPlaceholders(this.params, placeholderValues);
    const conn = (isPool(this.client) ? await this.client.getConnection() : this.client).connection;
    const { fields, query, rawQuery, joinsNotNullableMap, client, customResultMapper } = this;
    const hasRowsMapper = Boolean(fields || customResultMapper);
    const driverQuery = hasRowsMapper ? conn.query(query, params) : conn.query(rawQuery, params);
    const stream = driverQuery.stream();
    function dataListener() {
      stream.pause();
    }
    stream.on("data", dataListener);
    try {
      const onEnd = (0, import_node_events.once)(stream, "end");
      const onError = (0, import_node_events.once)(stream, "error");
      while (true) {
        stream.resume();
        const row = await Promise.race([onEnd, onError, new Promise((resolve) => stream.once("data", resolve))]);
        if (row === void 0 || Array.isArray(row) && row.length === 0) {
          break;
        } else if (row instanceof Error) {
          throw row;
        } else {
          if (hasRowsMapper) {
            if (customResultMapper) {
              const mappedRow = customResultMapper([row]);
              yield Array.isArray(mappedRow) ? mappedRow[0] : mappedRow;
            } else {
              yield mapResultRow(fields, row, joinsNotNullableMap);
            }
          } else {
            yield row;
          }
        }
      }
    } finally {
      stream.off("data", dataListener);
      if (isPool(client)) {
        conn.end();
      }
    }
  }
};
var MySql2Session = class _MySql2Session extends MySqlSession {
  constructor(client, dialect, schema, options) {
    super(dialect);
    this.client = client;
    this.schema = schema;
    this.options = options;
    this.logger = options.logger ?? new NoopLogger();
    this.cache = options.cache ?? new NoopCache();
    this.mode = options.mode;
  }
  static [entityKind] = "MySql2Session";
  logger;
  mode;
  cache;
  prepareQuery(query, fields, customResultMapper, generatedIds, returningIds, queryMetadata, cacheConfig) {
    return new MySql2PreparedQuery(
      this.client,
      query.sql,
      query.params,
      this.logger,
      this.cache,
      queryMetadata,
      cacheConfig,
      fields,
      customResultMapper,
      generatedIds,
      returningIds
    );
  }
  /**
   * @internal
   * What is its purpose?
   */
  async query(query, params) {
    this.logger.logQuery(query, params);
    const result = await this.client.query({
      sql: query,
      values: params,
      rowsAsArray: true,
      typeCast: function(field, next) {
        if (field.type === "TIMESTAMP" || field.type === "DATETIME" || field.type === "DATE") {
          return field.string();
        }
        return next();
      }
    });
    return result;
  }
  all(query) {
    const querySql = this.dialect.sqlToQuery(query);
    this.logger.logQuery(querySql.sql, querySql.params);
    return this.client.execute(querySql.sql, querySql.params).then((result) => result[0]);
  }
  async transaction(transaction, config) {
    const session = isPool(this.client) ? new _MySql2Session(
      await this.client.getConnection(),
      this.dialect,
      this.schema,
      this.options
    ) : this;
    const tx = new MySql2Transaction(
      this.dialect,
      session,
      this.schema,
      0,
      this.mode
    );
    if (config) {
      const setTransactionConfigSql = this.getSetTransactionSQL(config);
      if (setTransactionConfigSql) {
        await tx.execute(setTransactionConfigSql);
      }
      const startTransactionSql = this.getStartTransactionSQL(config);
      await (startTransactionSql ? tx.execute(startTransactionSql) : tx.execute(sql`begin`));
    } else {
      await tx.execute(sql`begin`);
    }
    try {
      const result = await transaction(tx);
      await tx.execute(sql`commit`);
      return result;
    } catch (err) {
      await tx.execute(sql`rollback`);
      throw err;
    } finally {
      if (isPool(this.client)) {
        session.client.release();
      }
    }
  }
};
var MySql2Transaction = class _MySql2Transaction extends MySqlTransaction {
  static [entityKind] = "MySql2Transaction";
  async transaction(transaction) {
    const savepointName = `sp${this.nestedIndex + 1}`;
    const tx = new _MySql2Transaction(
      this.dialect,
      this.session,
      this.schema,
      this.nestedIndex + 1,
      this.mode
    );
    await tx.execute(sql.raw(`savepoint ${savepointName}`));
    try {
      const result = await transaction(tx);
      await tx.execute(sql.raw(`release savepoint ${savepointName}`));
      return result;
    } catch (err) {
      await tx.execute(sql.raw(`rollback to savepoint ${savepointName}`));
      throw err;
    }
  }
};
function isPool(client) {
  return "getConnection" in client;
}

// node_modules/drizzle-orm/mysql2/driver.js
var MySql2Driver = class {
  constructor(client, dialect, options = {}) {
    this.client = client;
    this.dialect = dialect;
    this.options = options;
  }
  static [entityKind] = "MySql2Driver";
  createSession(schema, mode) {
    return new MySql2Session(this.client, this.dialect, schema, {
      logger: this.options.logger,
      mode,
      cache: this.options.cache
    });
  }
};
var MySql2Database = class extends MySqlDatabase {
  static [entityKind] = "MySql2Database";
};
function construct(client, config = {}) {
  const dialect = new MySqlDialect({ casing: config.casing });
  let logger;
  if (config.logger === true) {
    logger = new DefaultLogger();
  } else if (config.logger !== false) {
    logger = config.logger;
  }
  const clientForInstance = isCallbackClient(client) ? client.promise() : client;
  let schema;
  if (config.schema) {
    if (config.mode === void 0) {
      throw new DrizzleError({
        message: 'You need to specify "mode": "planetscale" or "default" when providing a schema. Read more: https://orm.drizzle.team/docs/rqb#modes'
      });
    }
    const tablesConfig = extractTablesRelationalConfig(
      config.schema,
      createTableRelationsHelpers
    );
    schema = {
      fullSchema: config.schema,
      schema: tablesConfig.tables,
      tableNamesMap: tablesConfig.tableNamesMap
    };
  }
  const mode = config.mode ?? "default";
  const driver = new MySql2Driver(clientForInstance, dialect, { logger, cache: config.cache });
  const session = driver.createSession(schema, mode);
  const db = new MySql2Database(dialect, session, schema, mode);
  db.$client = client;
  db.$cache = config.cache;
  if (db.$cache) {
    db.$cache["invalidate"] = config.cache?.onMutate;
  }
  return db;
}
function isCallbackClient(client) {
  return typeof client.promise === "function";
}
function drizzle(...params) {
  if (typeof params[0] === "string") {
    const connectionString = params[0];
    const instance = (0, import_mysql2.createPool)({
      uri: connectionString
    });
    return construct(instance, params[1]);
  }
  if (isConfig(params[0])) {
    const { connection, client, ...drizzleConfig } = params[0];
    if (client) return construct(client, drizzleConfig);
    const instance = typeof connection === "string" ? (0, import_mysql2.createPool)({
      uri: connection,
      supportBigNumbers: true
    }) : (0, import_mysql2.createPool)(connection);
    const db = construct(instance, drizzleConfig);
    return db;
  }
  return construct(params[0], params[1]);
}
((drizzle2) => {
  function mock(config) {
    return construct({}, config);
  }
  drizzle2.mock = mock;
})(drizzle || (drizzle = {}));
export {
  MySql2Database,
  MySql2Driver,
  MySql2PreparedQuery,
  MySql2Session,
  MySql2Transaction,
  MySqlDatabase,
  drizzle
};
//# sourceMappingURL=drizzle-orm_mysql2.js.map
