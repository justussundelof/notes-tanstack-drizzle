{
  "version": 3,
  "sources": ["../../@tanstack/router-core/src/utils.ts", "../../@tanstack/router-core/src/scroll-restoration.ts", "../../@tanstack/router-core/src/qss.ts", "../../@tanstack/router-core/src/searchParams.ts", "../../@tanstack/router-core/src/redirect.ts", "../../@tanstack/router-core/src/defer.ts", "../../seroval/src/core/compat.ts", "../../seroval/src/core/string.ts", "../../seroval/src/core/keys.ts", "../../seroval/src/core/utils/assert.ts", "../../seroval/src/core/reference.ts", "../../seroval/src/core/plugin.ts", "../../seroval/src/core/constants.ts", "../../seroval/src/core/node.ts", "../../seroval/src/core/literals.ts", "../../seroval/src/core/utils/error.ts", "../../seroval/src/core/utils/get-object-flag.ts", "../../seroval/src/core/base-primitives.ts", "../../seroval/src/core/errors.ts", "../../seroval/src/core/opaque-reference.ts", "../../seroval/src/core/function-string.ts", "../../seroval/src/core/special-reference.ts", "../../seroval/src/core/utils/deferred.ts", "../../seroval/src/core/stream.ts", "../../seroval/src/core/utils/iterator-to-sequence.ts", "../../seroval/src/core/utils/promise-to-result.ts", "../../seroval/src/core/context/parser.ts", "../../seroval/src/core/context/parser/async.ts", "../../seroval/src/core/cross/async.ts", "../../seroval/src/core/utils/typed-array.ts", "../../seroval/src/core/context/deserializer.ts", "../../seroval/src/core/cross/deserializer.ts", "../../seroval/src/core/utils/is-valid-identifier.ts", "../../seroval/src/core/context/serializer.ts", "../../seroval/src/core/cross/serializer.ts", "../../seroval/src/core/context/parser/sync.ts", "../../seroval/src/core/context/parser/stream.ts", "../../seroval/src/core/cross/stream.ts", "../../seroval/src/core/cross/sync.ts", "../../seroval/src/core/cross/index.ts", "../../seroval/src/core/tree/async.ts", "../../seroval/src/core/tree/deserializer.ts", "../../seroval/src/core/utils/get-identifier.ts", "../../seroval/src/core/tree/serializer.ts", "../../seroval/src/core/tree/sync.ts", "../../seroval/src/core/tree/index.ts", "../../seroval/src/core/Serializer.ts", "../../seroval-plugins/web/abort-signal.ts", "../../seroval-plugins/web/blob.ts", "../../seroval-plugins/web/custom-event.ts", "../../seroval-plugins/web/dom-exception.ts", "../../seroval-plugins/web/event.ts", "../../seroval-plugins/web/file.ts", "../../seroval-plugins/web/form-data.ts", "../../seroval-plugins/web/headers.ts", "../../seroval-plugins/web/image-data.ts", "../../seroval-plugins/web/readable-stream.ts", "../../seroval-plugins/web/request.ts", "../../seroval-plugins/web/response.ts", "../../seroval-plugins/web/url.ts", "../../seroval-plugins/web/url-search-params.ts", "../../@tanstack/router-core/src/ssr/serializer/ShallowErrorPlugin.ts", "../../@tanstack/router-ssr-query-core/src/index.ts", "../../@tanstack/react-router-ssr-query/src/index.tsx"],
  "sourcesContent": ["import type { RouteIds } from './routeInfo'\nimport type { AnyRouter } from './router'\n\nexport type Awaitable<T> = T | Promise<T>\nexport type NoInfer<T> = [T][T extends any ? 0 : never]\nexport type IsAny<TValue, TYesResult, TNoResult = TValue> = 1 extends 0 & TValue\n  ? TYesResult\n  : TNoResult\n\nexport type PickAsRequired<TValue, TKey extends keyof TValue> = Omit<\n  TValue,\n  TKey\n> &\n  Required<Pick<TValue, TKey>>\n\nexport type PickRequired<T> = {\n  [K in keyof T as undefined extends T[K] ? never : K]: T[K]\n}\n\nexport type PickOptional<T> = {\n  [K in keyof T as undefined extends T[K] ? K : never]: T[K]\n}\n\n// from https://stackoverflow.com/a/76458160\nexport type WithoutEmpty<T> = T extends any ? ({} extends T ? never : T) : never\n\nexport type Expand<T> = T extends object\n  ? T extends infer O\n    ? O extends Function\n      ? O\n      : { [K in keyof O]: O[K] }\n    : never\n  : T\n\nexport type DeepPartial<T> = T extends object\n  ? {\n      [P in keyof T]?: DeepPartial<T[P]>\n    }\n  : T\n\nexport type MakeDifferenceOptional<TLeft, TRight> = keyof TLeft &\n  keyof TRight extends never\n  ? TRight\n  : Omit<TRight, keyof TLeft & keyof TRight> & {\n      [K in keyof TLeft & keyof TRight]?: TRight[K]\n    }\n\n// from https://stackoverflow.com/a/53955431\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport type IsUnion<T, U extends T = T> = (\n  T extends any ? (U extends T ? false : true) : never\n) extends false\n  ? false\n  : true\n\nexport type IsNonEmptyObject<T> = T extends object\n  ? keyof T extends never\n    ? false\n    : true\n  : false\n\nexport type Assign<TLeft, TRight> = TLeft extends any\n  ? TRight extends any\n    ? IsNonEmptyObject<TLeft> extends false\n      ? TRight\n      : IsNonEmptyObject<TRight> extends false\n        ? TLeft\n        : keyof TLeft & keyof TRight extends never\n          ? TLeft & TRight\n          : Omit<TLeft, keyof TRight> & TRight\n    : never\n  : never\n\nexport type IntersectAssign<TLeft, TRight> = TLeft extends any\n  ? TRight extends any\n    ? IsNonEmptyObject<TLeft> extends false\n      ? TRight\n      : IsNonEmptyObject<TRight> extends false\n        ? TLeft\n        : TRight & TLeft\n    : never\n  : never\n\nexport type Timeout = ReturnType<typeof setTimeout>\n\nexport type Updater<TPrevious, TResult = TPrevious> =\n  | TResult\n  | ((prev?: TPrevious) => TResult)\n\nexport type NonNullableUpdater<TPrevious, TResult = TPrevious> =\n  | TResult\n  | ((prev: TPrevious) => TResult)\n\nexport type ExtractObjects<TUnion> = TUnion extends MergeAllPrimitive\n  ? never\n  : TUnion\n\nexport type PartialMergeAllObject<TUnion> =\n  ExtractObjects<TUnion> extends infer TObj\n    ? [TObj] extends [never]\n      ? never\n      : {\n          [TKey in TObj extends any ? keyof TObj : never]?: TObj extends any\n            ? TKey extends keyof TObj\n              ? TObj[TKey]\n              : never\n            : never\n        }\n    : never\n\nexport type MergeAllPrimitive =\n  | ReadonlyArray<any>\n  | number\n  | string\n  | bigint\n  | boolean\n  | symbol\n  | undefined\n  | null\n\nexport type ExtractPrimitives<TUnion> = TUnion extends MergeAllPrimitive\n  ? TUnion\n  : TUnion extends object\n    ? never\n    : TUnion\n\nexport type PartialMergeAll<TUnion> =\n  | ExtractPrimitives<TUnion>\n  | PartialMergeAllObject<TUnion>\n\nexport type Constrain<T, TConstraint, TDefault = TConstraint> =\n  | (T extends TConstraint ? T : never)\n  | TDefault\n\nexport type ConstrainLiteral<T, TConstraint, TDefault = TConstraint> =\n  | (T & TConstraint)\n  | TDefault\n\n/**\n * To be added to router types\n */\nexport type UnionToIntersection<T> = (\n  T extends any ? (arg: T) => any : never\n) extends (arg: infer T) => any\n  ? T\n  : never\n\n/**\n * Merges everything in a union into one object.\n * This mapped type is homomorphic which means it preserves stuff! :)\n */\nexport type MergeAllObjects<\n  TUnion,\n  TIntersected = UnionToIntersection<ExtractObjects<TUnion>>,\n> = [keyof TIntersected] extends [never]\n  ? never\n  : {\n      [TKey in keyof TIntersected]: TUnion extends any\n        ? TUnion[TKey & keyof TUnion]\n        : never\n    }\n\nexport type MergeAll<TUnion> =\n  | MergeAllObjects<TUnion>\n  | ExtractPrimitives<TUnion>\n\nexport type ValidateJSON<T> = ((...args: Array<any>) => any) extends T\n  ? unknown extends T\n    ? never\n    : 'Function is not serializable'\n  : { [K in keyof T]: ValidateJSON<T[K]> }\n\nexport type LooseReturnType<T> = T extends (\n  ...args: Array<any>\n) => infer TReturn\n  ? TReturn\n  : never\n\nexport type LooseAsyncReturnType<T> = T extends (\n  ...args: Array<any>\n) => infer TReturn\n  ? TReturn extends Promise<infer TReturn>\n    ? TReturn\n    : TReturn\n  : never\n\n/**\n * Return the last element of an array.\n * Intended for non-empty arrays used within router internals.\n */\nexport function last<T>(arr: Array<T>) {\n  return arr[arr.length - 1]\n}\n\nfunction isFunction(d: any): d is Function {\n  return typeof d === 'function'\n}\n\n/**\n * Apply a value-or-updater to a previous value.\n * Accepts either a literal value or a function of the previous value.\n */\nexport function functionalUpdate<TPrevious, TResult = TPrevious>(\n  updater: Updater<TPrevious, TResult> | NonNullableUpdater<TPrevious, TResult>,\n  previous: TPrevious,\n): TResult {\n  if (isFunction(updater)) {\n    return updater(previous)\n  }\n\n  return updater\n}\n\nconst hasOwn = Object.prototype.hasOwnProperty\n\n/**\n * This function returns `prev` if `_next` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between immutable JSON values for example.\n * Do not use this with signals\n */\nexport function replaceEqualDeep<T>(prev: any, _next: T): T {\n  if (prev === _next) {\n    return prev\n  }\n\n  const next = _next as any\n\n  const array = isPlainArray(prev) && isPlainArray(next)\n\n  if (!array && !(isPlainObject(prev) && isPlainObject(next))) return next\n\n  const prevItems = array ? prev : getEnumerableOwnKeys(prev)\n  if (!prevItems) return next\n  const nextItems = array ? next : getEnumerableOwnKeys(next)\n  if (!nextItems) return next\n  const prevSize = prevItems.length\n  const nextSize = nextItems.length\n  const copy: any = array ? new Array(nextSize) : {}\n\n  let equalItems = 0\n\n  for (let i = 0; i < nextSize; i++) {\n    const key = array ? i : (nextItems[i] as any)\n    const p = prev[key]\n    const n = next[key]\n\n    if (p === n) {\n      copy[key] = p\n      if (array ? i < prevSize : hasOwn.call(prev, key)) equalItems++\n      continue\n    }\n\n    if (\n      p === null ||\n      n === null ||\n      typeof p !== 'object' ||\n      typeof n !== 'object'\n    ) {\n      copy[key] = n\n      continue\n    }\n\n    const v = replaceEqualDeep(p, n)\n    copy[key] = v\n    if (v === p) equalItems++\n  }\n\n  return prevSize === nextSize && equalItems === prevSize ? prev : copy\n}\n\n/**\n * Equivalent to `Reflect.ownKeys`, but ensures that objects are \"clone-friendly\":\n * will return false if object has any non-enumerable properties.\n */\nfunction getEnumerableOwnKeys(o: object) {\n  const keys = []\n  const names = Object.getOwnPropertyNames(o)\n  for (const name of names) {\n    if (!Object.prototype.propertyIsEnumerable.call(o, name)) return false\n    keys.push(name)\n  }\n  const symbols = Object.getOwnPropertySymbols(o)\n  for (const symbol of symbols) {\n    if (!Object.prototype.propertyIsEnumerable.call(o, symbol)) return false\n    keys.push(symbol)\n  }\n  return keys\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\nexport function isPlainObject(o: any) {\n  if (!hasObjectPrototype(o)) {\n    return false\n  }\n\n  // If has modified constructor\n  const ctor = o.constructor\n  if (typeof ctor === 'undefined') {\n    return true\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype\n  if (!hasObjectPrototype(prot)) {\n    return false\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false\n  }\n\n  // Most likely a plain Object\n  return true\n}\n\nfunction hasObjectPrototype(o: any) {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n\n/**\n * Check if a value is a \"plain\" array (no extra enumerable keys).\n */\nexport function isPlainArray(value: unknown): value is Array<unknown> {\n  return Array.isArray(value) && value.length === Object.keys(value).length\n}\n\n/**\n * Perform a deep equality check with options for partial comparison and\n * ignoring `undefined` values. Optimized for router state comparisons.\n */\nexport function deepEqual(\n  a: any,\n  b: any,\n  opts?: { partial?: boolean; ignoreUndefined?: boolean },\n): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length !== b.length) return false\n    for (let i = 0, l = a.length; i < l; i++) {\n      if (!deepEqual(a[i], b[i], opts)) return false\n    }\n    return true\n  }\n\n  if (isPlainObject(a) && isPlainObject(b)) {\n    const ignoreUndefined = opts?.ignoreUndefined ?? true\n\n    if (opts?.partial) {\n      for (const k in b) {\n        if (!ignoreUndefined || b[k] !== undefined) {\n          if (!deepEqual(a[k], b[k], opts)) return false\n        }\n      }\n      return true\n    }\n\n    let aCount = 0\n    if (!ignoreUndefined) {\n      aCount = Object.keys(a).length\n    } else {\n      for (const k in a) {\n        if (a[k] !== undefined) aCount++\n      }\n    }\n\n    let bCount = 0\n    for (const k in b) {\n      if (!ignoreUndefined || b[k] !== undefined) {\n        bCount++\n        if (bCount > aCount || !deepEqual(a[k], b[k], opts)) return false\n      }\n    }\n\n    return aCount === bCount\n  }\n\n  return false\n}\n\nexport type StringLiteral<T> = T extends string\n  ? string extends T\n    ? string\n    : T\n  : never\n\nexport type ThrowOrOptional<T, TThrow extends boolean> = TThrow extends true\n  ? T\n  : T | undefined\n\nexport type StrictOrFrom<\n  TRouter extends AnyRouter,\n  TFrom,\n  TStrict extends boolean = true,\n> = TStrict extends false\n  ? {\n      from?: never\n      strict: TStrict\n    }\n  : {\n      from: ConstrainLiteral<TFrom, RouteIds<TRouter['routeTree']>>\n      strict?: TStrict\n    }\n\nexport type ThrowConstraint<\n  TStrict extends boolean,\n  TThrow extends boolean,\n> = TStrict extends false ? (TThrow extends true ? never : TThrow) : TThrow\n\nexport type ControlledPromise<T> = Promise<T> & {\n  resolve: (value: T) => void\n  reject: (value: any) => void\n  status: 'pending' | 'resolved' | 'rejected'\n  value?: T\n}\n\n/**\n * Create a promise with exposed resolve/reject and status fields.\n * Useful for coordinating async router lifecycle operations.\n */\nexport function createControlledPromise<T>(onResolve?: (value: T) => void) {\n  let resolveLoadPromise!: (value: T) => void\n  let rejectLoadPromise!: (value: any) => void\n\n  const controlledPromise = new Promise<T>((resolve, reject) => {\n    resolveLoadPromise = resolve\n    rejectLoadPromise = reject\n  }) as ControlledPromise<T>\n\n  controlledPromise.status = 'pending'\n\n  controlledPromise.resolve = (value: T) => {\n    controlledPromise.status = 'resolved'\n    controlledPromise.value = value\n    resolveLoadPromise(value)\n    onResolve?.(value)\n  }\n\n  controlledPromise.reject = (e) => {\n    controlledPromise.status = 'rejected'\n    rejectLoadPromise(e)\n  }\n\n  return controlledPromise\n}\n\n/**\n * Heuristically detect dynamic import \"module not found\" errors\n * across major browsers for lazy route component handling.\n */\nexport function isModuleNotFoundError(error: any): boolean {\n  // chrome: \"Failed to fetch dynamically imported module: http://localhost:5173/src/routes/posts.index.tsx?tsr-split\"\n  // firefox: \"error loading dynamically imported module: http://localhost:5173/src/routes/posts.index.tsx?tsr-split\"\n  // safari: \"Importing a module script failed.\"\n  if (typeof error?.message !== 'string') return false\n  return (\n    error.message.startsWith('Failed to fetch dynamically imported module') ||\n    error.message.startsWith('error loading dynamically imported module') ||\n    error.message.startsWith('Importing a module script failed')\n  )\n}\n\nexport function isPromise<T>(\n  value: Promise<Awaited<T>> | T,\n): value is Promise<Awaited<T>> {\n  return Boolean(\n    value &&\n      typeof value === 'object' &&\n      typeof (value as Promise<T>).then === 'function',\n  )\n}\n\nexport function findLast<T>(\n  array: ReadonlyArray<T>,\n  predicate: (item: T) => boolean,\n): T | undefined {\n  for (let i = array.length - 1; i >= 0; i--) {\n    const item = array[i]!\n    if (predicate(item)) return item\n  }\n  return undefined\n}\n\nconst DECODE_IGNORE_LIST = Array.from(\n  new Map([\n    ['%', '%25'],\n    ['\\\\', '%5C'],\n  ]).values(),\n)\n\nexport function decodePath(\n  part: string,\n  decodeIgnore: Array<string> = DECODE_IGNORE_LIST,\n): string {\n  function splitAndDecode(\n    part: string,\n    decodeIgnore: Array<string>,\n    startIndex = 0,\n  ): string {\n    // decode the path / path segment by splitting it into parts defined by the ignore list.\n    // once these pieces have been decoded, join them back together to form the final decoded path segment with the ignored character in place.\n    // we walk through the ignore list linearly, breaking the segment up into pieces and decoding each piece individually.\n    // use index traversal to avoid making unnecessary copies of the array.\n    for (let i = startIndex; i < decodeIgnore.length; i++) {\n      const char = decodeIgnore[i]!.toUpperCase()\n\n      // check if the part includes the current ignore character\n      // if it doesn't continue to the next ignore character\n      if (part.includes(char)) {\n        // split the part into pieces that needs to be checked and decoded\n        const partsToDecode = part.split(char)\n        const partsToJoin: Array<string> = []\n\n        // now check and decode each piece individually taking into consideration the remaining ignored characters.\n        // since we are walking through the list linearly, we only need to consider ignore items not yet traversed.\n        for (const partToDecode of partsToDecode) {\n          // once we have traversed the entire ignore list, each decoded part is returned.\n          partsToJoin.push(splitAndDecode(partToDecode, decodeIgnore, i + 1))\n        }\n\n        // and join them back together to form the final decoded path segment with the ignored character in place.\n        return partsToJoin.join(char)\n      }\n    }\n\n    // once we have reached the end of the ignore list, we start walking back returning each decoded part.\n    // should there be no matching characters, the path segment as a whole will be decoded.\n    try {\n      return decodeURI(part)\n    } catch {\n      // if the decoding fails, try to decode the various parts leaving the malformed tags in place\n      return part.replaceAll(/%[0-9A-F]{2}/g, (match) => {\n        try {\n          return decodeURI(match)\n        } catch {\n          return match\n        }\n      })\n    }\n  }\n\n  // if the path segment does not contain any encoded uri components return the path as is\n  if (part === '' || !/%[0-9A-Fa-f]{2}/g.test(part)) return part\n\n  // ensure all encoded characters are uppercase\n  const normalizedPart = part.replaceAll(/%[0-9a-f]{2}/g, (match) =>\n    match.toUpperCase(),\n  )\n\n  return splitAndDecode(normalizedPart, decodeIgnore)\n}\n", "import { functionalUpdate } from './utils'\nimport type { AnyRouter } from './router'\nimport type { ParsedLocation } from './location'\nimport type { NonNullableUpdater } from './utils'\nimport type { HistoryLocation } from '@tanstack/history'\n\nexport type ScrollRestorationEntry = { scrollX: number; scrollY: number }\n\nexport type ScrollRestorationByElement = Record<string, ScrollRestorationEntry>\n\nexport type ScrollRestorationByKey = Record<string, ScrollRestorationByElement>\n\nexport type ScrollRestorationCache = {\n  state: ScrollRestorationByKey\n  set: (updater: NonNullableUpdater<ScrollRestorationByKey>) => void\n}\nexport type ScrollRestorationOptions = {\n  getKey?: (location: ParsedLocation) => string\n  scrollBehavior?: ScrollToOptions['behavior']\n}\n\nfunction getSafeSessionStorage() {\n  try {\n    if (\n      typeof window !== 'undefined' &&\n      typeof window.sessionStorage === 'object'\n    ) {\n      return window.sessionStorage\n    }\n  } catch {\n    // silent\n  }\n  return undefined\n}\n\n/** SessionStorage key used to persist scroll restoration state. */\n/** SessionStorage key used to store scroll positions across navigations. */\n/** SessionStorage key used to store scroll positions across navigations. */\nexport const storageKey = 'tsr-scroll-restoration-v1_3'\n\nconst throttle = (fn: (...args: Array<any>) => void, wait: number) => {\n  let timeout: any\n  return (...args: Array<any>) => {\n    if (!timeout) {\n      timeout = setTimeout(() => {\n        fn(...args)\n        timeout = null\n      }, wait)\n    }\n  }\n}\n\nfunction createScrollRestorationCache(): ScrollRestorationCache | null {\n  const safeSessionStorage = getSafeSessionStorage()\n  if (!safeSessionStorage) {\n    return null\n  }\n\n  const persistedState = safeSessionStorage.getItem(storageKey)\n  let state: ScrollRestorationByKey = persistedState\n    ? JSON.parse(persistedState)\n    : {}\n\n  return {\n    state,\n    // This setter is simply to make sure that we set the sessionStorage right\n    // after the state is updated. It doesn't necessarily need to be a functional\n    // update.\n    set: (updater) => (\n      (state = functionalUpdate(updater, state) || state),\n      safeSessionStorage.setItem(storageKey, JSON.stringify(state))\n    ),\n  }\n}\n\n/** In-memory handle to the persisted scroll restoration cache. */\n/** In-memory handle to the persisted scroll restoration cache. */\n/** In-memory handle to the persisted scroll restoration cache. */\nexport const scrollRestorationCache = createScrollRestorationCache()\n\n/**\n * The default `getKey` function for `useScrollRestoration`.\n * It returns the `key` from the location state or the `href` of the location.\n *\n * The `location.href` is used as a fallback to support the use case where the location state is not available like the initial render.\n */\n\n/**\n * Default scroll restoration cache key: location state key or full href.\n */\n/**\n * Default scroll restoration cache key: location state key or full href.\n */\n/**\n * Default scroll restoration cache key: location state key or full href.\n */\nexport const defaultGetScrollRestorationKey = (location: ParsedLocation) => {\n  return location.state.__TSR_key! || location.href\n}\n\n/** Best-effort nth-child CSS selector for a given element. */\nexport function getCssSelector(el: any): string {\n  const path = []\n  let parent: HTMLElement\n  while ((parent = el.parentNode)) {\n    path.push(\n      `${el.tagName}:nth-child(${Array.prototype.indexOf.call(parent.children, el) + 1})`,\n    )\n    el = parent\n  }\n  return `${path.reverse().join(' > ')}`.toLowerCase()\n}\n\nlet ignoreScroll = false\n\n// NOTE: This function must remain pure and not use any outside variables\n// unless they are passed in as arguments. Why? Because we need to be able to\n// toString() it into a script tag to execute as early as possible in the browser\n// during SSR. Additionally, we also call it from within the router lifecycle\n/**\n * Restore scroll positions for window/elements based on cached entries.\n */\n/**\n * Restore scroll positions for window/elements based on cached entries.\n */\nexport function restoreScroll({\n  storageKey,\n  key,\n  behavior,\n  shouldScrollRestoration,\n  scrollToTopSelectors,\n  location,\n}: {\n  storageKey: string\n  key?: string\n  behavior?: ScrollToOptions['behavior']\n  shouldScrollRestoration?: boolean\n  scrollToTopSelectors?: Array<string | (() => Element | null | undefined)>\n  location?: HistoryLocation\n}) {\n  let byKey: ScrollRestorationByKey\n\n  try {\n    byKey = JSON.parse(sessionStorage.getItem(storageKey) || '{}')\n  } catch (error) {\n    console.error(error)\n    return\n  }\n\n  const resolvedKey = key || window.history.state?.__TSR_key\n  const elementEntries = byKey[resolvedKey]\n\n  //\n  ignoreScroll = true\n\n  //\n  scroll: {\n    // If we have a cached entry for this location state,\n    // we always need to prefer that over the hash scroll.\n    if (\n      shouldScrollRestoration &&\n      elementEntries &&\n      Object.keys(elementEntries).length > 0\n    ) {\n      for (const elementSelector in elementEntries) {\n        const entry = elementEntries[elementSelector]!\n        if (elementSelector === 'window') {\n          window.scrollTo({\n            top: entry.scrollY,\n            left: entry.scrollX,\n            behavior,\n          })\n        } else if (elementSelector) {\n          const element = document.querySelector(elementSelector)\n          if (element) {\n            element.scrollLeft = entry.scrollX\n            element.scrollTop = entry.scrollY\n          }\n        }\n      }\n\n      break scroll\n    }\n\n    // If we don't have a cached entry for the hash,\n    // Which means we've never seen this location before,\n    // we need to check if there is a hash in the URL.\n    // If there is, we need to scroll it's ID into view.\n    const hash = (location ?? window.location).hash.split('#', 2)[1]\n\n    if (hash) {\n      const hashScrollIntoViewOptions =\n        window.history.state?.__hashScrollIntoViewOptions ?? true\n\n      if (hashScrollIntoViewOptions) {\n        const el = document.getElementById(hash)\n        if (el) {\n          el.scrollIntoView(hashScrollIntoViewOptions)\n        }\n      }\n\n      break scroll\n    }\n\n    // If there is no cached entry for the hash and there is no hash in the URL,\n    // we need to scroll to the top of the page for every scrollToTop element\n    const scrollOptions = { top: 0, left: 0, behavior }\n    window.scrollTo(scrollOptions)\n    if (scrollToTopSelectors) {\n      for (const selector of scrollToTopSelectors) {\n        if (selector === 'window') continue\n        const element =\n          typeof selector === 'function'\n            ? selector()\n            : document.querySelector(selector)\n        if (element) element.scrollTo(scrollOptions)\n      }\n    }\n  }\n\n  //\n  ignoreScroll = false\n}\n\n/** Setup global listeners and hooks to support scroll restoration. */\n/** Setup global listeners and hooks to support scroll restoration. */\nexport function setupScrollRestoration(router: AnyRouter, force?: boolean) {\n  if (!scrollRestorationCache && !router.isServer) {\n    return\n  }\n  const shouldScrollRestoration =\n    force ?? router.options.scrollRestoration ?? false\n\n  if (shouldScrollRestoration) {\n    router.isScrollRestoring = true\n  }\n\n  if (\n    router.isServer ||\n    router.isScrollRestorationSetup ||\n    !scrollRestorationCache\n  ) {\n    return\n  }\n\n  router.isScrollRestorationSetup = true\n\n  //\n  ignoreScroll = false\n\n  const getKey =\n    router.options.getScrollRestorationKey || defaultGetScrollRestorationKey\n\n  window.history.scrollRestoration = 'manual'\n\n  // // Create a MutationObserver to monitor DOM changes\n  // const mutationObserver = new MutationObserver(() => {\n  //   ;ignoreScroll = true\n  //   requestAnimationFrame(() => {\n  //     ;ignoreScroll = false\n\n  //     // Attempt to restore scroll position on each dom\n  //     // mutation until the user scrolls. We do this\n  //     // because dynamic content may come in at different\n  //     // ticks after the initial render and we want to\n  //     // keep up with that content as much as possible.\n  //     // As soon as the user scrolls, we no longer need\n  //     // to attempt router.\n  //     // console.log('mutation observer restoreScroll')\n  //     restoreScroll(\n  //       storageKey,\n  //       getKey(router.state.location),\n  //       router.options.scrollRestorationBehavior,\n  //     )\n  //   })\n  // })\n\n  // const observeDom = () => {\n  //   // Observe changes to the entire document\n  //   mutationObserver.observe(document, {\n  //     childList: true, // Detect added or removed child nodes\n  //     subtree: true, // Monitor all descendants\n  //     characterData: true, // Detect text content changes\n  //   })\n  // }\n\n  // const unobserveDom = () => {\n  //   mutationObserver.disconnect()\n  // }\n\n  // observeDom()\n\n  const onScroll = (event: Event) => {\n    // unobserveDom()\n\n    if (ignoreScroll || !router.isScrollRestoring) {\n      return\n    }\n\n    let elementSelector = ''\n\n    if (event.target === document || event.target === window) {\n      elementSelector = 'window'\n    } else {\n      const attrId = (event.target as Element).getAttribute(\n        'data-scroll-restoration-id',\n      )\n\n      if (attrId) {\n        elementSelector = `[data-scroll-restoration-id=\"${attrId}\"]`\n      } else {\n        elementSelector = getCssSelector(event.target)\n      }\n    }\n\n    const restoreKey = getKey(router.state.location)\n\n    scrollRestorationCache.set((state) => {\n      const keyEntry = (state[restoreKey] ||= {} as ScrollRestorationByElement)\n\n      const elementEntry = (keyEntry[elementSelector] ||=\n        {} as ScrollRestorationEntry)\n\n      if (elementSelector === 'window') {\n        elementEntry.scrollX = window.scrollX || 0\n        elementEntry.scrollY = window.scrollY || 0\n      } else if (elementSelector) {\n        const element = document.querySelector(elementSelector)\n        if (element) {\n          elementEntry.scrollX = element.scrollLeft || 0\n          elementEntry.scrollY = element.scrollTop || 0\n        }\n      }\n\n      return state\n    })\n  }\n\n  // Throttle the scroll event to avoid excessive updates\n  if (typeof document !== 'undefined') {\n    document.addEventListener('scroll', throttle(onScroll, 100), true)\n  }\n\n  router.subscribe('onRendered', (event) => {\n    // unobserveDom()\n\n    const cacheKey = getKey(event.toLocation)\n\n    // If the user doesn't want to restore the scroll position,\n    // we don't need to do anything.\n    if (!router.resetNextScroll) {\n      router.resetNextScroll = true\n      return\n    }\n    if (typeof router.options.scrollRestoration === 'function') {\n      const shouldRestore = router.options.scrollRestoration({\n        location: router.latestLocation,\n      })\n      if (!shouldRestore) {\n        return\n      }\n    }\n\n    restoreScroll({\n      storageKey,\n      key: cacheKey,\n      behavior: router.options.scrollRestorationBehavior,\n      shouldScrollRestoration: router.isScrollRestoring,\n      scrollToTopSelectors: router.options.scrollToTopSelectors,\n      location: router.history.location,\n    })\n\n    if (router.isScrollRestoring) {\n      // Mark the location as having been seen\n      scrollRestorationCache.set((state) => {\n        state[cacheKey] ||= {} as ScrollRestorationByElement\n\n        return state\n      })\n    }\n  })\n}\n\n/**\n * @private\n * Handles hash-based scrolling after navigation completes.\n * To be used in framework-specific <Transitioner> components during the onResolved event.\n *\n * Provides hash scrolling for programmatic navigation when default browser handling is prevented.\n * @param router The router instance containing current location and state\n */\n/**\n * @private\n * Handles hash-based scrolling after navigation completes.\n * To be used in framework-specific <Transitioner> components during the onResolved event.\n *\n * Provides hash scrolling for programmatic navigation when default browser handling is prevented.\n * @param router The router instance containing current location and state\n */\n/**\n * @private\n * Handles hash-based scrolling after navigation completes.\n * To be used in framework-specific Transitioners.\n */\nexport function handleHashScroll(router: AnyRouter) {\n  if (typeof document !== 'undefined' && (document as any).querySelector) {\n    const hashScrollIntoViewOptions =\n      router.state.location.state.__hashScrollIntoViewOptions ?? true\n\n    if (hashScrollIntoViewOptions && router.state.location.hash !== '') {\n      const el = document.getElementById(router.state.location.hash)\n      if (el) {\n        el.scrollIntoView(hashScrollIntoViewOptions)\n      }\n    }\n  }\n}\n", "/**\n * Program is a reimplementation of the `qss` package:\n * Copyright (c) Luke Edwards luke.edwards05@gmail.com, MIT License\n * https://github.com/lukeed/qss/blob/master/license.md\n *\n * This reimplementation uses modern browser APIs\n * (namely URLSearchParams) and TypeScript while still\n * maintaining the original functionality and interface.\n *\n * Update: this implementation has also been mangled to\n * fit exactly our use-case (single value per key in encoding).\n */\n\n/**\n * Encodes an object into a query string.\n * @param obj - The object to encode into a query string.\n * @param stringify - An optional custom stringify function.\n * @returns The encoded query string.\n * @example\n * ```\n * // Example input: encode({ token: 'foo', key: 'value' })\n * // Expected output: \"token=foo&key=value\"\n * ```\n */\n/** Encode a plain object into a URL query string using URLSearchParams. */\nexport function encode(\n  obj: Record<string, any>,\n  stringify: (value: any) => string = String,\n): string {\n  const result = new URLSearchParams()\n\n  for (const key in obj) {\n    const val = obj[key]\n    if (val !== undefined) {\n      result.set(key, stringify(val))\n    }\n  }\n\n  return result.toString()\n}\n\n/**\n * Converts a string value to its appropriate type (string, number, boolean).\n * @param mix - The string value to convert.\n * @returns The converted value.\n * @example\n * // Example input: toValue(\"123\")\n * // Expected output: 123\n */\n/** Convert a string into a primitive boolean/number when possible. */\nfunction toValue(str: unknown) {\n  if (!str) return ''\n\n  if (str === 'false') return false\n  if (str === 'true') return true\n  return +str * 0 === 0 && +str + '' === str ? +str : str\n}\n\n/**\n * Decodes a query string into an object.\n * @param str - The query string to decode.\n * @returns The decoded key-value pairs in an object format.\n * @example\n * // Example input: decode(\"token=foo&key=value\")\n * // Expected output: { \"token\": \"foo\", \"key\": \"value\" }\n */\n/** Decode a URL query string into an object with basic type coercion. */\nexport function decode(str: any): any {\n  const searchParams = new URLSearchParams(str)\n\n  const result: Record<string, unknown> = {}\n\n  for (const [key, value] of searchParams.entries()) {\n    const previousValue = result[key]\n    if (previousValue == null) {\n      result[key] = toValue(value)\n    } else if (Array.isArray(previousValue)) {\n      previousValue.push(toValue(value))\n    } else {\n      result[key] = [previousValue, toValue(value)]\n    }\n  }\n\n  return result\n}\n", "import { decode, encode } from './qss'\nimport type { AnySchema } from './validators'\n\n/** Default `parseSearch` that strips leading '?' and JSON-parses values. */\n/** Default `parseSearch` that strips leading '?' and JSON-parses values. */\n/** Default `parseSearch` that strips leading '?' and JSON-parses values. */\nexport const defaultParseSearch = parseSearchWith(JSON.parse)\n/** Default `stringifySearch` using JSON.stringify for complex values. */\nexport const defaultStringifySearch = stringifySearchWith(\n  JSON.stringify,\n  JSON.parse,\n)\n\n/**\n * Build a `parseSearch` function using a provided JSON-like parser.\n *\n * The returned function strips a leading `?`, decodes values, and attempts to\n * JSON-parse string values using the given `parser`.\n *\n * @param parser Function to parse a string value (e.g. `JSON.parse`).\n * @returns A `parseSearch` function compatible with `Router` options.\n * @link https://tanstack.com/router/latest/docs/framework/react/guide/custom-search-param-serialization\n */\n/** Build a parseSearch function using a provided JSON-like parser. */\nexport function parseSearchWith(parser: (str: string) => any) {\n  return (searchStr: string): AnySchema => {\n    if (searchStr[0] === '?') {\n      searchStr = searchStr.substring(1)\n    }\n\n    const query: Record<string, unknown> = decode(searchStr)\n\n    // Try to parse any query params that might be json\n    for (const key in query) {\n      const value = query[key]\n      if (typeof value === 'string') {\n        try {\n          query[key] = parser(value)\n        } catch (_err) {\n          // silent\n        }\n      }\n    }\n\n    return query\n  }\n}\n\n/**\n * Build a `stringifySearch` function using a provided serializer.\n *\n * Non-primitive values are serialized with `stringify`. If a `parser` is\n * supplied, string values that are parseable are re-serialized to ensure\n * symmetry with `parseSearch`.\n *\n * @param stringify Function to serialize a value (e.g. `JSON.stringify`).\n * @param parser Optional parser to detect parseable strings.\n * @returns A `stringifySearch` function compatible with `Router` options.\n * @link https://tanstack.com/router/latest/docs/framework/react/guide/custom-search-param-serialization\n */\n/** Build a stringifySearch function using a provided serializer/parser. */\nexport function stringifySearchWith(\n  stringify: (search: any) => string,\n  parser?: (str: string) => any,\n) {\n  const hasParser = typeof parser === 'function'\n  function stringifyValue(val: any) {\n    if (typeof val === 'object' && val !== null) {\n      try {\n        return stringify(val)\n      } catch (_err) {\n        // silent\n      }\n    } else if (hasParser && typeof val === 'string') {\n      try {\n        // Check if it's a valid parseable string.\n        // If it is, then stringify it again.\n        parser(val)\n        return stringify(val)\n      } catch (_err) {\n        // silent\n      }\n    }\n    return val\n  }\n\n  return (search: Record<string, any>) => {\n    const searchStr = encode(search, stringifyValue)\n    return searchStr ? `?${searchStr}` : ''\n  }\n}\n\nexport type SearchSerializer = (searchObj: Record<string, any>) => string\nexport type SearchParser = (searchStr: string) => Record<string, any>\n", "import type { NavigateOptions } from './link'\nimport type { AnyRouter, RegisteredRouter } from './router'\n\nexport type AnyRedirect = Redirect<any, any, any, any, any>\n\n/**\n * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RedirectType)\n */\nexport type Redirect<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends string = string,\n  TTo extends string | undefined = undefined,\n  TMaskFrom extends string = TFrom,\n  TMaskTo extends string = '.',\n> = Response & {\n  options: NavigateOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo>\n  redirectHandled?: boolean\n}\n\nexport type RedirectOptions<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends string = string,\n  TTo extends string | undefined = undefined,\n  TMaskFrom extends string = TFrom,\n  TMaskTo extends string = '.',\n> = {\n  href?: string\n  /**\n   * @deprecated Use `statusCode` instead\n   **/\n  code?: number\n  /**\n   * The HTTP status code to use when redirecting.\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RedirectType#statuscode-property)\n   */\n  statusCode?: number\n  /**\n   * If provided, will throw the redirect object instead of returning it. This can be useful in places where `throwing` in a function might cause it to have a return type of `never`. In that case, you can use `redirect({ throw: true })` to throw the redirect object instead of returning it.\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RedirectType#throw-property)\n   */\n  throw?: any\n  /**\n   * The HTTP headers to use when redirecting.\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RedirectType#headers-property)\n   */\n  headers?: HeadersInit\n} & NavigateOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo>\n\nexport type ResolvedRedirect<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends string = string,\n  TTo extends string = '',\n  TMaskFrom extends string = TFrom,\n  TMaskTo extends string = '',\n> = Redirect<TRouter, TFrom, TTo, TMaskFrom, TMaskTo>\n\n/**\n * Create a redirect Response understood by TanStack Router.\n *\n * Use from route `loader`/`beforeLoad` or server functions to trigger a\n * navigation. If `throw: true` is set, the redirect is thrown instead of\n * returned. When an absolute `href` is supplied and `reloadDocument` is not\n * set, a full-document navigation is inferred.\n *\n * @param opts Options for the redirect. Common fields:\n * - `href`: absolute URL for external redirects; infers `reloadDocument`.\n * - `statusCode`: HTTP status code to use (defaults to 307).\n * - `headers`: additional headers to include on the Response.\n * - Standard navigation options like `to`, `params`, `search`, `replace`,\n *   and `reloadDocument` for internal redirects.\n * @returns A Response augmented with router navigation options.\n * @link https://tanstack.com/router/latest/docs/framework/react/api/router/redirectFunction\n */\n/**\n * Create a redirect Response understood by TanStack Router.\n * Use inside loaders/beforeLoad or server handlers to trigger navigation.\n */\nexport function redirect<\n  TRouter extends AnyRouter = RegisteredRouter,\n  const TTo extends string | undefined = '.',\n  const TFrom extends string = string,\n  const TMaskFrom extends string = TFrom,\n  const TMaskTo extends string = '',\n>(\n  opts: RedirectOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo>,\n): Redirect<TRouter, TFrom, TTo, TMaskFrom, TMaskTo> {\n  opts.statusCode = opts.statusCode || opts.code || 307\n\n  if (!opts.reloadDocument && typeof opts.href === 'string') {\n    try {\n      new URL(opts.href)\n      opts.reloadDocument = true\n    } catch {}\n  }\n\n  const headers = new Headers(opts.headers)\n  if (opts.href && headers.get('Location') === null) {\n    headers.set('Location', opts.href)\n  }\n\n  const response = new Response(null, {\n    status: opts.statusCode,\n    headers,\n  })\n\n  ;(response as Redirect<TRouter, TFrom, TTo, TMaskFrom, TMaskTo>).options =\n    opts\n\n  if (opts.throw) {\n    throw response\n  }\n\n  return response as Redirect<TRouter, TFrom, TTo, TMaskFrom, TMaskTo>\n}\n\n/** Check whether a value is a TanStack Router redirect Response. */\n/** Check whether a value is a TanStack Router redirect Response. */\nexport function isRedirect(obj: any): obj is AnyRedirect {\n  return obj instanceof Response && !!(obj as any).options\n}\n\n/** True if value is a redirect with a resolved `href` location. */\n/** True if value is a redirect with a resolved `href` location. */\nexport function isResolvedRedirect(\n  obj: any,\n): obj is AnyRedirect & { options: { href: string } } {\n  return isRedirect(obj) && !!obj.options.href\n}\n\n/** Parse a serialized redirect object back into a redirect Response. */\n/** Parse a serialized redirect object back into a redirect Response. */\nexport function parseRedirect(obj: any) {\n  if (obj !== null && typeof obj === 'object' && obj.isSerializedRedirect) {\n    return redirect(obj)\n  }\n\n  return undefined\n}\n", "import { defaultSerializeError } from './router'\n\n/**\n * Well-known symbol used by {@link defer} to tag a promise with\n * its deferred state. Consumers can read `promise[TSR_DEFERRED_PROMISE]`\n * to access `status`, `data`, or `error`.\n */\nexport const TSR_DEFERRED_PROMISE = Symbol.for('TSR_DEFERRED_PROMISE')\n\nexport type DeferredPromiseState<T> =\n  | {\n      status: 'pending'\n      data?: T\n      error?: unknown\n    }\n  | {\n      status: 'success'\n      data: T\n    }\n  | {\n      status: 'error'\n      data?: T\n      error: unknown\n    }\n\nexport type DeferredPromise<T> = Promise<T> & {\n  [TSR_DEFERRED_PROMISE]: DeferredPromiseState<T>\n}\n\n/**\n * Wrap a promise with a deferred state for use with `<Await>` and `useAwaited`.\n *\n * The returned promise is augmented with internal state (status/data/error)\n * so UI can read progress or suspend until it settles.\n *\n * @param _promise The promise to wrap.\n * @param options Optional config. Provide `serializeError` to customize how\n * errors are serialized for transfer.\n * @returns The same promise with attached deferred metadata.\n * @link https://tanstack.com/router/latest/docs/framework/react/api/router/deferFunction\n */\nexport function defer<T>(\n  _promise: Promise<T>,\n  options?: {\n    serializeError?: typeof defaultSerializeError\n  },\n) {\n  const promise = _promise as DeferredPromise<T>\n  // this is already deferred promise\n  if ((promise as any)[TSR_DEFERRED_PROMISE]) {\n    return promise\n  }\n  promise[TSR_DEFERRED_PROMISE] = { status: 'pending' }\n\n  promise\n    .then((data) => {\n      promise[TSR_DEFERRED_PROMISE].status = 'success'\n      promise[TSR_DEFERRED_PROMISE].data = data\n    })\n    .catch((error) => {\n      promise[TSR_DEFERRED_PROMISE].status = 'error'\n      ;(promise[TSR_DEFERRED_PROMISE] as any).error = {\n        data: (options?.serializeError ?? defaultSerializeError)(error),\n        __isServerError: true,\n      }\n    })\n\n  return promise\n}\n", "/**\n * References\n * - https://compat-table.github.io/compat-table/es6/\n * - MDN\n */\n\nexport const enum Feature {\n  AggregateError = 0x01,\n  ArrowFunction = 0x02,\n  ErrorPrototypeStack = 0x04,\n  ObjectAssign = 0x08,\n  BigIntTypedArray = 0x10,\n}\n\nexport const ALL_ENABLED =\n  Feature.AggregateError |\n  Feature.ArrowFunction |\n  Feature.ErrorPrototypeStack |\n  Feature.ObjectAssign |\n  Feature.BigIntTypedArray;\n", "export function serializeChar(str: string): string | undefined {\n  switch (str) {\n    case '\"':\n      return '\\\\\"';\n    case '\\\\':\n      return '\\\\\\\\';\n    case '\\n':\n      return '\\\\n';\n    case '\\r':\n      return '\\\\r';\n    case '\\b':\n      return '\\\\b';\n    case '\\t':\n      return '\\\\t';\n    case '\\f':\n      return '\\\\f';\n    case '<':\n      return '\\\\x3C';\n    case '\\u2028':\n      return '\\\\u2028';\n    case '\\u2029':\n      return '\\\\u2029';\n    default:\n      return undefined;\n  }\n}\n\n// Written by https://github.com/DylanPiercey and is distributed under the MIT license.\n// Creates a JavaScript double quoted string and escapes all characters\n// not listed as DoubleStringCharacters on\n// Also includes \"<\" to escape \"</script>\" and \"\\\" to avoid invalid escapes in the output.\n// http://www.ecma-international.org/ecma-262/5.1/#sec-7.8.4\nexport function serializeString(str: string): string {\n  let result = '';\n  let lastPos = 0;\n  let replacement: string | undefined;\n  for (let i = 0, len = str.length; i < len; i++) {\n    replacement = serializeChar(str[i]);\n    if (replacement) {\n      result += str.slice(lastPos, i) + replacement;\n      lastPos = i + 1;\n    }\n  }\n  if (lastPos === 0) {\n    result = str;\n  } else {\n    result += str.slice(lastPos);\n  }\n  return result;\n}\n\nfunction deserializeReplacer(str: string): string {\n  switch (str) {\n    case '\\\\\\\\':\n      return '\\\\';\n    case '\\\\\"':\n      return '\"';\n    case '\\\\n':\n      return '\\n';\n    case '\\\\r':\n      return '\\r';\n    case '\\\\b':\n      return '\\b';\n    case '\\\\t':\n      return '\\t';\n    case '\\\\f':\n      return '\\f';\n    case '\\\\x3C':\n      return '\\x3C';\n    case '\\\\u2028':\n      return '\\u2028';\n    case '\\\\u2029':\n      return '\\u2029';\n    default:\n      return str;\n  }\n}\n\nexport function deserializeString(str: string): string {\n  return str.replace(\n    /(\\\\\\\\|\\\\\"|\\\\n|\\\\r|\\\\b|\\\\t|\\\\f|\\\\u2028|\\\\u2029|\\\\x3C)/g,\n    deserializeReplacer,\n  );\n}\n", "import { serializeString } from './string';\n\n// Used for mapping isomorphic references\nexport const REFERENCES_KEY = '__SEROVAL_REFS__';\n\nexport const GLOBAL_CONTEXT_REFERENCES = '$R';\n\nconst GLOBAL_CONTEXT_R = `self.${GLOBAL_CONTEXT_REFERENCES}`;\n\nexport function getCrossReferenceHeader(id?: string): string {\n  if (id == null) {\n    return `${GLOBAL_CONTEXT_R}=${GLOBAL_CONTEXT_R}||[]`;\n  }\n  return `(${GLOBAL_CONTEXT_R}=${GLOBAL_CONTEXT_R}||{})[\"${serializeString(\n    id,\n  )}\"]=[]`;\n}\n", "export default function assert(cond: unknown, error: Error): asserts cond {\n  if (!cond) {\n    throw error;\n  }\n}\n", "import {\n  SerovalMissingReferenceError,\n  SerovalMissingReferenceForIdError,\n} from '..';\nimport { REFERENCES_KEY } from './keys';\nimport assert from './utils/assert';\n\nconst REFERENCE = new Map<unknown, string>();\nconst INV_REFERENCE = new Map<string, unknown>();\n\nexport function createReference<T>(id: string, value: T): T {\n  REFERENCE.set(value, id);\n  INV_REFERENCE.set(id, value);\n  return value;\n}\n\nexport function hasReferenceID<T>(value: T): boolean {\n  return REFERENCE.has(value);\n}\n\nexport function hasReference(id: string): boolean {\n  return INV_REFERENCE.has(id);\n}\n\nexport function getReferenceID<T>(value: T): string {\n  assert(hasReferenceID(value), new SerovalMissingReferenceError(value));\n  return REFERENCE.get(value)!;\n}\n\nexport function getReference<T>(id: string): T {\n  assert(hasReference(id), new SerovalMissingReferenceForIdError(id));\n  return INV_REFERENCE.get(id) as T;\n}\n\nif (typeof globalThis !== 'undefined') {\n  Object.defineProperty(globalThis, REFERENCES_KEY, {\n    value: INV_REFERENCE,\n    configurable: true,\n    writable: false,\n    enumerable: false,\n  });\n} else if (typeof window !== 'undefined') {\n  Object.defineProperty(window, REFERENCES_KEY, {\n    value: INV_REFERENCE,\n    configurable: true,\n    writable: false,\n    enumerable: false,\n  });\n} else if (typeof self !== 'undefined') {\n  Object.defineProperty(self, REFERENCES_KEY, {\n    value: INV_REFERENCE,\n    configurable: true,\n    writable: false,\n    enumerable: false,\n  });\n} else if (typeof global !== 'undefined') {\n  Object.defineProperty(global, REFERENCES_KEY, {\n    value: INV_REFERENCE,\n    configurable: true,\n    writable: false,\n    enumerable: false,\n  });\n}\n", "import type BaseDeserializerContext from './context/deserializer';\nimport type BaseAsyncParserContext from './context/parser/async';\nimport type BaseStreamParserContext from './context/parser/stream';\nimport type BaseSyncParserContext from './context/parser/sync';\nimport type BaseSerializerContext from './context/serializer';\n\nexport type SerovalMode = 'vanilla' | 'cross';\n\nexport interface PluginData {\n  id: number;\n}\n\nexport interface Plugin<Value, Node> {\n  /**\n   * A unique string that helps idenfity the plugin\n   */\n  tag: string;\n  /**\n   * List of dependency plugins\n   */\n  extends?: Plugin<any, any>[];\n  /**\n   * Method to test if a value is an expected value of the plugin\n   * @param value\n   */\n  test(value: unknown): boolean;\n  /**\n   * Parsing modes\n   */\n  parse: {\n    sync?: (value: Value, ctx: BaseSyncParserContext, data: PluginData) => Node;\n    async?: (\n      value: Value,\n      ctx: BaseAsyncParserContext,\n      data: PluginData,\n    ) => Promise<Node>;\n    stream?: (\n      value: Value,\n      ctx: BaseStreamParserContext,\n      data: PluginData,\n    ) => Node;\n  };\n  /**\n   * Convert the parsed node into a JS string\n   */\n  serialize(node: Node, ctx: BaseSerializerContext, data: PluginData): string;\n  /**\n   * Convert the parsed node into its runtime equivalent.\n   */\n  deserialize(\n    node: Node,\n    ctx: BaseDeserializerContext,\n    data: PluginData,\n  ): Value;\n}\n\nexport function createPlugin<Value, Node>(\n  plugin: Plugin<Value, Node>,\n): Plugin<Value, Node> {\n  return plugin;\n}\n\nexport interface PluginAccessOptions {\n  plugins?: Plugin<any, any>[];\n}\n\nfunction dedupePlugins(\n  deduped: Set<Plugin<any, any>>,\n  plugins: Plugin<any, any>[],\n): void {\n  for (let i = 0, len = plugins.length; i < len; i++) {\n    const current = plugins[i];\n    if (!deduped.has(current)) {\n      deduped.add(current);\n      if (current.extends) {\n        dedupePlugins(deduped, current.extends);\n      }\n    }\n  }\n}\n\nexport function resolvePlugins(\n  plugins?: Plugin<any, any>[],\n): Plugin<any, any>[] | undefined {\n  if (plugins) {\n    const deduped = new Set<Plugin<any, any>>();\n    dedupePlugins(deduped, plugins);\n    return [...deduped];\n  }\n  return undefined;\n}\n", "export const enum SerovalConstant {\n  Null = 0,\n  Undefined = 1,\n  True = 2,\n  False = 3,\n  NegZero = 4,\n  Inf = 5,\n  NegInf = 6,\n  Nan = 7,\n}\n\nexport const enum SerovalNodeType {\n  Number = 0,\n  String = 1,\n  Constant = 2,\n  BigInt = 3,\n  IndexedValue = 4,\n  Date = 5,\n  RegExp = 6,\n  Set = 7,\n  Map = 8,\n  Array = 9,\n  Object = 10,\n  NullConstructor = 11,\n  Promise = 12,\n  Error = 13,\n  AggregateError = 14,\n  TypedArray = 15,\n  BigIntTypedArray = 16,\n  WKSymbol = 17,\n  Reference = 18,\n  ArrayBuffer = 19,\n  DataView = 20,\n  Boxed = 21,\n  PromiseConstructor = 22,\n  PromiseSuccess = 23,\n  PromiseFailure = 24,\n  Plugin = 25,\n  SpecialReference = 26,\n  IteratorFactory = 27,\n  IteratorFactoryInstance = 28,\n  AsyncIteratorFactory = 29,\n  AsyncIteratorFactoryInstance = 30,\n  StreamConstructor = 31,\n  StreamNext = 32,\n  StreamThrow = 33,\n  StreamReturn = 34,\n}\n\nexport const enum SerovalObjectFlags {\n  None = 0,\n  NonExtensible = 1,\n  Sealed = 2,\n  Frozen = 3,\n}\n\nexport const enum Symbols {\n  AsyncIterator = 0,\n  HasInstance = 1,\n  IsConcatSpreadable = 2,\n  Iterator = 3,\n  Match = 4,\n  MatchAll = 5,\n  Replace = 6,\n  Search = 7,\n  Species = 8,\n  Split = 9,\n  ToPrimitive = 10,\n  ToStringTag = 11,\n  Unscopables = 12,\n}\n\nexport const SYMBOL_STRING: Record<Symbols, string> = {\n  [Symbols.AsyncIterator]: 'Symbol.asyncIterator',\n  [Symbols.HasInstance]: 'Symbol.hasInstance',\n  [Symbols.IsConcatSpreadable]: 'Symbol.isConcatSpreadable',\n  [Symbols.Iterator]: 'Symbol.iterator',\n  [Symbols.Match]: 'Symbol.match',\n  [Symbols.MatchAll]: 'Symbol.matchAll',\n  [Symbols.Replace]: 'Symbol.replace',\n  [Symbols.Search]: 'Symbol.search',\n  [Symbols.Species]: 'Symbol.species',\n  [Symbols.Split]: 'Symbol.split',\n  [Symbols.ToPrimitive]: 'Symbol.toPrimitive',\n  [Symbols.ToStringTag]: 'Symbol.toStringTag',\n  [Symbols.Unscopables]: 'Symbol.unscopables',\n};\n\nexport const INV_SYMBOL_REF = /* @__PURE__ */ {\n  [Symbol.asyncIterator]: Symbols.AsyncIterator,\n  [Symbol.hasInstance]: Symbols.HasInstance,\n  [Symbol.isConcatSpreadable]: Symbols.IsConcatSpreadable,\n  [Symbol.iterator]: Symbols.Iterator,\n  [Symbol.match]: Symbols.Match,\n  [Symbol.matchAll]: Symbols.MatchAll,\n  [Symbol.replace]: Symbols.Replace,\n  [Symbol.search]: Symbols.Search,\n  [Symbol.species]: Symbols.Species,\n  [Symbol.split]: Symbols.Split,\n  [Symbol.toPrimitive]: Symbols.ToPrimitive,\n  [Symbol.toStringTag]: Symbols.ToStringTag,\n  [Symbol.unscopables]: Symbols.Unscopables,\n};\n\nexport type WellKnownSymbols = keyof typeof INV_SYMBOL_REF;\n\nexport const SYMBOL_REF: Record<Symbols, WellKnownSymbols> = {\n  [Symbols.AsyncIterator]: Symbol.asyncIterator,\n  [Symbols.HasInstance]: Symbol.hasInstance,\n  [Symbols.IsConcatSpreadable]: Symbol.isConcatSpreadable,\n  [Symbols.Iterator]: Symbol.iterator,\n  [Symbols.Match]: Symbol.match,\n  [Symbols.MatchAll]: Symbol.matchAll,\n  [Symbols.Replace]: Symbol.replace,\n  [Symbols.Search]: Symbol.search,\n  [Symbols.Species]: Symbol.species,\n  [Symbols.Split]: Symbol.split,\n  [Symbols.ToPrimitive]: Symbol.toPrimitive,\n  [Symbols.ToStringTag]: Symbol.toStringTag,\n  [Symbols.Unscopables]: Symbol.unscopables,\n};\n\nexport const CONSTANT_STRING: Record<SerovalConstant, string> = {\n  [SerovalConstant.True]: '!0',\n  [SerovalConstant.False]: '!1',\n  [SerovalConstant.Undefined]: 'void 0',\n  [SerovalConstant.Null]: 'null',\n  [SerovalConstant.NegZero]: '-0',\n  [SerovalConstant.Inf]: '1/0',\n  [SerovalConstant.NegInf]: '-1/0',\n  [SerovalConstant.Nan]: '0/0',\n};\n\nexport const CONSTANT_VAL: Record<SerovalConstant, unknown> = {\n  [SerovalConstant.True]: true,\n  [SerovalConstant.False]: false,\n  [SerovalConstant.Undefined]: undefined,\n  [SerovalConstant.Null]: null,\n  [SerovalConstant.NegZero]: -0,\n  [SerovalConstant.Inf]: Number.POSITIVE_INFINITY,\n  [SerovalConstant.NegInf]: Number.NEGATIVE_INFINITY,\n  [SerovalConstant.Nan]: Number.NaN,\n};\n\nexport const enum ErrorConstructorTag {\n  Error = 0,\n  EvalError = 1,\n  RangeError = 2,\n  ReferenceError = 3,\n  SyntaxError = 4,\n  TypeError = 5,\n  URIError = 6,\n}\n\nexport const ERROR_CONSTRUCTOR_STRING: Record<ErrorConstructorTag, string> = {\n  [ErrorConstructorTag.Error]: 'Error',\n  [ErrorConstructorTag.EvalError]: 'EvalError',\n  [ErrorConstructorTag.RangeError]: 'RangeError',\n  [ErrorConstructorTag.ReferenceError]: 'ReferenceError',\n  [ErrorConstructorTag.SyntaxError]: 'SyntaxError',\n  [ErrorConstructorTag.TypeError]: 'TypeError',\n  [ErrorConstructorTag.URIError]: 'URIError',\n};\n\ntype ErrorConstructors =\n  | ErrorConstructor\n  | EvalErrorConstructor\n  | RangeErrorConstructor\n  | ReferenceErrorConstructor\n  | SyntaxErrorConstructor\n  | TypeErrorConstructor\n  | URIErrorConstructor;\n\nexport const ERROR_CONSTRUCTOR: Record<ErrorConstructorTag, ErrorConstructors> =\n  {\n    [ErrorConstructorTag.Error]: Error,\n    [ErrorConstructorTag.EvalError]: EvalError,\n    [ErrorConstructorTag.RangeError]: RangeError,\n    [ErrorConstructorTag.ReferenceError]: ReferenceError,\n    [ErrorConstructorTag.SyntaxError]: SyntaxError,\n    [ErrorConstructorTag.TypeError]: TypeError,\n    [ErrorConstructorTag.URIError]: URIError,\n  };\n\nexport const NIL = undefined;\n", "import type { SerovalNodeType } from './constants';\nimport type { SerovalNode } from './types';\n\ntype ExtractedNodeType<T extends SerovalNodeType> = Extract<\n  SerovalNode,\n  { t: T }\n>;\n\nexport function createSerovalNode<\n  T extends SerovalNodeType,\n  N extends ExtractedNodeType<T>,\n>(\n  t: T,\n  i: N['i'],\n  s: N['s'],\n  l: N['l'],\n  c: N['c'],\n  m: N['m'],\n  p: N['p'],\n  e: N['e'],\n  a: N['a'],\n  f: N['f'],\n  b: N['b'],\n  o: N['o'],\n): N {\n  return {\n    t,\n    i,\n    s,\n    l,\n    c,\n    m,\n    p,\n    e,\n    a,\n    f,\n    b,\n    o,\n  } as N;\n}\n", "import { NIL, SerovalConstant, SerovalNodeType } from './constants';\nimport { createSerovalNode } from './node';\nimport type { SerovalConstantNode } from './types';\n\nfunction createConstantNode(value: SerovalConstant): SerovalConstantNode {\n  return createSerovalNode(\n    SerovalNodeType.Constant,\n    NIL,\n    value,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport const TRUE_NODE = /* @__PURE__ */ createConstantNode(\n  SerovalConstant.True,\n);\nexport const FALSE_NODE = /* @__PURE__ */ createConstantNode(\n  SerovalConstant.False,\n);\nexport const UNDEFINED_NODE = /* @__PURE__ */ createConstantNode(\n  SerovalConstant.Undefined,\n);\nexport const NULL_NODE = /* @__PURE__ */ createConstantNode(\n  SerovalConstant.Null,\n);\nexport const NEG_ZERO_NODE = /* @__PURE__ */ createConstantNode(\n  SerovalConstant.NegZero,\n);\nexport const INFINITY_NODE = /* @__PURE__ */ createConstantNode(\n  SerovalConstant.Inf,\n);\nexport const NEG_INFINITY_NODE = /* @__PURE__ */ createConstantNode(\n  SerovalConstant.NegInf,\n);\nexport const NAN_NODE = /* @__PURE__ */ createConstantNode(SerovalConstant.Nan);\n", "import { Feature } from '../compat';\nimport { ERROR_CONSTRUCTOR_STRING, ErrorConstructorTag } from '../constants';\n\ntype ErrorValue =\n  | Error\n  | AggregateError\n  | EvalError\n  | RangeError\n  | ReferenceError\n  | TypeError\n  | SyntaxError\n  | URIError;\n\nexport function getErrorConstructor(error: ErrorValue): ErrorConstructorTag {\n  if (error instanceof EvalError) {\n    return ErrorConstructorTag.EvalError;\n  }\n  if (error instanceof RangeError) {\n    return ErrorConstructorTag.RangeError;\n  }\n  if (error instanceof ReferenceError) {\n    return ErrorConstructorTag.ReferenceError;\n  }\n  if (error instanceof SyntaxError) {\n    return ErrorConstructorTag.SyntaxError;\n  }\n  if (error instanceof TypeError) {\n    return ErrorConstructorTag.TypeError;\n  }\n  if (error instanceof URIError) {\n    return ErrorConstructorTag.URIError;\n  }\n  return ErrorConstructorTag.Error;\n}\n\nfunction getInitialErrorOptions(\n  error: Error,\n): Record<string, unknown> | undefined {\n  const construct = ERROR_CONSTRUCTOR_STRING[getErrorConstructor(error)];\n  // Name has been modified\n  if (error.name !== construct) {\n    return { name: error.name };\n  }\n  if (error.constructor.name !== construct) {\n    // Otherwise, name is overriden because\n    // the Error class is extended\n    return { name: error.constructor.name };\n  }\n  return {};\n}\n\nexport function getErrorOptions(\n  error: Error,\n  features: number,\n): Record<string, unknown> | undefined {\n  let options = getInitialErrorOptions(error);\n  const names = Object.getOwnPropertyNames(error);\n  for (let i = 0, len = names.length, name: string; i < len; i++) {\n    name = names[i];\n    if (name !== 'name' && name !== 'message') {\n      if (name === 'stack') {\n        if (features & Feature.ErrorPrototypeStack) {\n          options = options || {};\n          options[name] = error[name as keyof Error];\n        }\n      } else {\n        options = options || {};\n        options[name] = error[name as keyof Error];\n      }\n    }\n  }\n  return options;\n}\n", "import { SerovalObjectFlags } from '../constants';\n\nexport function getObjectFlag(obj: unknown): SerovalObjectFlags {\n  if (Object.isFrozen(obj)) {\n    return SerovalObjectFlags.Frozen;\n  }\n  if (Object.isSealed(obj)) {\n    return SerovalObjectFlags.Sealed;\n  }\n  if (Object.isExtensible(obj)) {\n    return SerovalObjectFlags.None;\n  }\n  return SerovalObjectFlags.NonExtensible;\n}\n", "import type { WellKnownSymbols } from './constants';\nimport { INV_SYMBOL_REF, NIL, SerovalNodeType } from './constants';\nimport {\n  INFINITY_NODE,\n  NAN_NODE,\n  NEG_INFINITY_NODE,\n  NEG_ZERO_NODE,\n} from './literals';\nimport { createSerovalNode } from './node';\nimport { getReferenceID } from './reference';\nimport { serializeString } from './string';\nimport type {\n  SerovalAggregateErrorNode,\n  SerovalArrayBufferNode,\n  SerovalArrayNode,\n  SerovalAsyncIteratorFactoryInstanceNode,\n  SerovalBigIntNode,\n  SerovalBigIntTypedArrayNode,\n  SerovalBoxedNode,\n  SerovalConstantNode,\n  SerovalDataViewNode,\n  SerovalDateNode,\n  SerovalErrorNode,\n  SerovalIndexedValueNode,\n  SerovalIteratorFactoryInstanceNode,\n  SerovalNode,\n  SerovalNodeWithID,\n  SerovalNumberNode,\n  SerovalObjectRecordNode,\n  SerovalPluginNode,\n  SerovalReferenceNode,\n  SerovalRegExpNode,\n  SerovalSetNode,\n  SerovalStreamConstructorNode,\n  SerovalStreamNextNode,\n  SerovalStreamReturnNode,\n  SerovalStreamThrowNode,\n  SerovalStringNode,\n  SerovalTypedArrayNode,\n  SerovalWKSymbolNode,\n} from './types';\nimport { getErrorConstructor } from './utils/error';\nimport { getObjectFlag } from './utils/get-object-flag';\nimport type {\n  BigIntTypedArrayValue,\n  TypedArrayValue,\n} from './utils/typed-array';\n\nexport function createNumberNode(\n  value: number,\n): SerovalConstantNode | SerovalNumberNode {\n  switch (value) {\n    case Number.POSITIVE_INFINITY:\n      return INFINITY_NODE;\n    case Number.NEGATIVE_INFINITY:\n      return NEG_INFINITY_NODE;\n  }\n  if (value !== value) {\n    return NAN_NODE;\n  }\n  if (Object.is(value, -0)) {\n    return NEG_ZERO_NODE;\n  }\n  return createSerovalNode(\n    SerovalNodeType.Number,\n    NIL,\n    value,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createStringNode(value: string): SerovalStringNode {\n  return createSerovalNode(\n    SerovalNodeType.String,\n    NIL,\n    serializeString(value),\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createBigIntNode(current: bigint): SerovalBigIntNode {\n  return createSerovalNode(\n    SerovalNodeType.BigInt,\n    NIL,\n    '' + current,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createIndexedValueNode(id: number): SerovalIndexedValueNode {\n  return createSerovalNode(\n    SerovalNodeType.IndexedValue,\n    id,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createDateNode(id: number, current: Date): SerovalDateNode {\n  const timestamp = current.valueOf();\n  return createSerovalNode(\n    SerovalNodeType.Date,\n    id,\n    timestamp !== timestamp ? '' : current.toISOString(),\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createRegExpNode(\n  id: number,\n  current: RegExp,\n): SerovalRegExpNode {\n  return createSerovalNode(\n    SerovalNodeType.RegExp,\n    id,\n    NIL,\n    NIL,\n    serializeString(current.source),\n    current.flags,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createArrayBufferNode(\n  id: number,\n  current: ArrayBuffer,\n): SerovalArrayBufferNode {\n  const bytes = new Uint8Array(current);\n  const len = bytes.length;\n  const values = new Array<number>(len);\n  for (let i = 0; i < len; i++) {\n    values[i] = bytes[i];\n  }\n  return createSerovalNode(\n    SerovalNodeType.ArrayBuffer,\n    id,\n    values,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createWKSymbolNode(\n  id: number,\n  current: WellKnownSymbols,\n): SerovalWKSymbolNode {\n  return createSerovalNode(\n    SerovalNodeType.WKSymbol,\n    id,\n    INV_SYMBOL_REF[current],\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createReferenceNode<T>(\n  id: number,\n  ref: T,\n): SerovalReferenceNode {\n  return createSerovalNode(\n    SerovalNodeType.Reference,\n    id,\n    serializeString(getReferenceID(ref)),\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createPluginNode(\n  id: number,\n  tag: string,\n  value: unknown,\n): SerovalPluginNode {\n  return createSerovalNode(\n    SerovalNodeType.Plugin,\n    id,\n    value,\n    NIL,\n    serializeString(tag),\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createArrayNode(\n  id: number,\n  current: unknown[],\n  parsedItems: SerovalNode[],\n): SerovalArrayNode {\n  return createSerovalNode(\n    SerovalNodeType.Array,\n    id,\n    NIL,\n    current.length,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    parsedItems,\n    NIL,\n    NIL,\n    getObjectFlag(current),\n  );\n}\n\nexport function createBoxedNode(\n  id: number,\n  boxed: SerovalNode,\n): SerovalBoxedNode {\n  return createSerovalNode(\n    SerovalNodeType.Boxed,\n    id,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    boxed,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createTypedArrayNode(\n  id: number,\n  current: TypedArrayValue,\n  buffer: SerovalNode,\n): SerovalTypedArrayNode {\n  return createSerovalNode(\n    SerovalNodeType.TypedArray,\n    id,\n    NIL,\n    current.length,\n    current.constructor.name,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    buffer,\n    current.byteOffset,\n    NIL,\n  );\n}\n\nexport function createBigIntTypedArrayNode(\n  id: number,\n  current: BigIntTypedArrayValue,\n  buffer: SerovalNode,\n): SerovalBigIntTypedArrayNode {\n  return createSerovalNode(\n    SerovalNodeType.BigIntTypedArray,\n    id,\n    NIL,\n    current.length,\n    current.constructor.name,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    buffer,\n    current.byteOffset,\n    NIL,\n  );\n}\n\nexport function createDataViewNode(\n  id: number,\n  current: DataView,\n  buffer: SerovalNode,\n): SerovalDataViewNode {\n  return createSerovalNode(\n    SerovalNodeType.DataView,\n    id,\n    NIL,\n    current.byteLength,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    buffer,\n    current.byteOffset,\n    NIL,\n  );\n}\n\nexport function createErrorNode(\n  id: number,\n  current: Error,\n  options: SerovalObjectRecordNode | undefined,\n): SerovalErrorNode {\n  return createSerovalNode(\n    SerovalNodeType.Error,\n    id,\n    getErrorConstructor(current),\n    NIL,\n    NIL,\n    serializeString(current.message),\n    options,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createAggregateErrorNode(\n  id: number,\n  current: AggregateError,\n  options: SerovalObjectRecordNode | undefined,\n): SerovalAggregateErrorNode {\n  return createSerovalNode(\n    SerovalNodeType.AggregateError,\n    id,\n    getErrorConstructor(current),\n    NIL,\n    NIL,\n    serializeString(current.message),\n    options,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createSetNode(\n  id: number,\n  size: number,\n  items: SerovalNode[],\n): SerovalSetNode {\n  return createSerovalNode(\n    SerovalNodeType.Set,\n    id,\n    NIL,\n    size,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    items,\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createIteratorFactoryInstanceNode(\n  factory: SerovalNodeWithID,\n  items: SerovalNode,\n): SerovalIteratorFactoryInstanceNode {\n  return createSerovalNode(\n    SerovalNodeType.IteratorFactoryInstance,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    [factory, items],\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createAsyncIteratorFactoryInstanceNode(\n  factory: SerovalNodeWithID,\n  items: SerovalNode,\n): SerovalAsyncIteratorFactoryInstanceNode {\n  return createSerovalNode(\n    SerovalNodeType.AsyncIteratorFactoryInstance,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    [factory, items],\n    NIL,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createStreamConstructorNode(\n  id: number,\n  factory: SerovalNodeWithID,\n  sequence: SerovalNode[],\n): SerovalStreamConstructorNode {\n  return createSerovalNode(\n    SerovalNodeType.StreamConstructor,\n    id,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    sequence,\n    factory,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createStreamNextNode(\n  id: number,\n  parsed: SerovalNode,\n): SerovalStreamNextNode {\n  return createSerovalNode(\n    SerovalNodeType.StreamNext,\n    id,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    parsed,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createStreamThrowNode(\n  id: number,\n  parsed: SerovalNode,\n): SerovalStreamThrowNode {\n  return createSerovalNode(\n    SerovalNodeType.StreamThrow,\n    id,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    parsed,\n    NIL,\n    NIL,\n  );\n}\n\nexport function createStreamReturnNode(\n  id: number,\n  parsed: SerovalNode,\n): SerovalStreamReturnNode {\n  return createSerovalNode(\n    SerovalNodeType.StreamReturn,\n    id,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    parsed,\n    NIL,\n    NIL,\n  );\n}\n", "import { serializeString } from './string';\nimport type { SerovalNode } from './types';\n\nconst { toString: objectToString } = /* @__PURE__ */ Object.prototype;\n\nfunction getErrorMessage(type: string, cause: any): string {\n  if (cause instanceof Error) {\n    return `Seroval caught an error during the ${type} process.\n  \n${cause.name}\n${cause.message}\n\n- For more information, please check the \"cause\" property of this error.\n- If you believe this is an error in Seroval, please submit an issue at https://github.com/lxsmnsyc/seroval/issues/new`;\n  }\n  return `Seroval caught an error during the ${type} process.\n\n\"${objectToString.call(cause)}\"\n\nFor more information, please check the \"cause\" property of this error.`;\n}\n\nexport class SerovalError extends Error {\n  constructor(\n    type: string,\n    public cause: any,\n  ) {\n    super(getErrorMessage(type, cause));\n  }\n}\n\nexport class SerovalParserError extends SerovalError {\n  constructor(cause: any) {\n    super('parsing', cause);\n  }\n}\n\nexport class SerovalSerializationError extends SerovalError {\n  constructor(cause: any) {\n    super('serialization', cause);\n  }\n}\n\nexport class SerovalDeserializationError extends SerovalError {\n  constructor(cause: any) {\n    super('deserialization', cause);\n  }\n}\n\nexport class SerovalUnsupportedTypeError extends Error {\n  constructor(public value: unknown) {\n    super(\n      `The value ${objectToString.call(value)} of type \"${typeof value}\" cannot be parsed/serialized.\n      \nThere are few workarounds for this problem:\n- Transform the value in a way that it can be serialized.\n- If the reference is present on multiple runtimes (isomorphic), you can use the Reference API to map the references.`,\n    );\n  }\n}\n\nexport class SerovalUnsupportedNodeError extends Error {\n  constructor(node: SerovalNode) {\n    super('Unsupported node type \"' + node.t + '\".');\n  }\n}\n\nexport class SerovalMissingPluginError extends Error {\n  constructor(tag: string) {\n    super('Missing plugin for tag \"' + tag + '\".');\n  }\n}\n\nexport class SerovalMissingInstanceError extends Error {\n  constructor(tag: string) {\n    super('Missing \"' + tag + '\" instance.');\n  }\n}\n\nexport class SerovalMissingReferenceError extends Error {\n  constructor(public value: unknown) {\n    super(\n      'Missing reference for the value \"' +\n        objectToString.call(value) +\n        '\" of type \"' +\n        typeof value +\n        '\"',\n    );\n  }\n}\n\nexport class SerovalMissingReferenceForIdError extends Error {\n  constructor(id: string) {\n    super('Missing reference for id \"' + serializeString(id) + '\"');\n  }\n}\n\nexport class SerovalUnknownTypedArrayError extends Error {\n  constructor(name: string) {\n    super('Unknown TypedArray \"' + name + '\"');\n  }\n}\n", "/**\n * An opaque reference allows hiding values from the serializer.\n */\nexport class OpaqueReference<V, R = undefined> {\n  constructor(\n    public readonly value: V,\n    public readonly replacement?: R,\n  ) {}\n}\n", "import { Feature } from './compat';\n\nexport function createFunction(\n  features: number,\n  parameters: string[],\n  body: string,\n): string {\n  if (features & Feature.ArrowFunction) {\n    const joined =\n      parameters.length === 1\n        ? parameters[0]\n        : '(' + parameters.join(',') + ')';\n    return joined + '=>' + (body.startsWith('{') ? '(' + body + ')' : body);\n  }\n  return 'function(' + parameters.join(',') + '){return ' + body + '}';\n}\n\nexport function createEffectfulFunction(\n  features: number,\n  parameters: string[],\n  body: string,\n): string {\n  if (features & Feature.ArrowFunction) {\n    const joined =\n      parameters.length === 1\n        ? parameters[0]\n        : '(' + parameters.join(',') + ')';\n    return joined + '=>{' + body + '}';\n  }\n  return 'function(' + parameters.join(',') + '){' + body + '}';\n}\n", "import { createEffectfulFunction, createFunction } from './function-string';\n\nexport const ITERATOR = {};\n\nexport const ASYNC_ITERATOR = {};\n\nexport const enum SpecialReference {\n  MapSentinel = 0,\n  PromiseConstructor = 1,\n  PromiseSuccess = 2,\n  PromiseFailure = 3,\n  StreamConstructor = 4,\n}\n\n/**\n * Placeholder references\n */\nexport const SPECIAL_REFS: Record<SpecialReference, unknown> = {\n  [SpecialReference.MapSentinel]: {},\n  [SpecialReference.PromiseConstructor]: {},\n  [SpecialReference.PromiseSuccess]: {},\n  [SpecialReference.PromiseFailure]: {},\n  [SpecialReference.StreamConstructor]: {},\n};\n\nfunction serializePromiseConstructor(features: number): string {\n  return createFunction(\n    features,\n    ['r'],\n    '(r.p=new Promise(' +\n      createEffectfulFunction(features, ['s', 'f'], 'r.s=s,r.f=f') +\n      '))',\n  );\n}\n\nfunction serializePromiseSuccess(features: number): string {\n  return createEffectfulFunction(\n    features,\n    ['r', 'd'],\n    'r.s(d),r.p.s=1,r.p.v=d',\n  );\n}\n\nfunction serializePromiseFailure(features: number): string {\n  return createEffectfulFunction(\n    features,\n    ['r', 'd'],\n    'r.f(d),r.p.s=2,r.p.v=d',\n  );\n}\n\nfunction serializeStreamConstructor(features: number): string {\n  return createFunction(\n    features,\n    ['b', 'a', 's', 'l', 'p', 'f', 'e', 'n'],\n    '(b=[],a=!0,s=!1,l=[],p=0,f=' +\n      createEffectfulFunction(\n        features,\n        ['v', 'm', 'x'],\n        'for(x=0;x<p;x++)l[x]&&l[x][m](v)',\n      ) +\n      ',n=' +\n      createEffectfulFunction(\n        features,\n        ['o', 'x', 'z', 'c'],\n        'for(x=0,z=b.length;x<z;x++)(c=b[x],(!a&&x===z-1)?o[s?\"return\":\"throw\"](c):o.next(c))',\n      ) +\n      ',e=' +\n      createFunction(\n        features,\n        ['o', 't'],\n        '(a&&(l[t=p++]=o),n(o),' +\n          createEffectfulFunction(features, [], 'a&&(l[t]=void 0)') +\n          ')',\n      ) +\n      ',{__SEROVAL_STREAM__:!0,on:' +\n      createFunction(features, ['o'], 'e(o)') +\n      ',next:' +\n      createEffectfulFunction(features, ['v'], 'a&&(b.push(v),f(v,\"next\"))') +\n      ',throw:' +\n      createEffectfulFunction(\n        features,\n        ['v'],\n        'a&&(b.push(v),f(v,\"throw\"),a=s=!1,l.length=0)',\n      ) +\n      ',return:' +\n      createEffectfulFunction(\n        features,\n        ['v'],\n        'a&&(b.push(v),f(v,\"return\"),a=!1,s=!0,l.length=0)',\n      ) +\n      '})',\n  );\n}\n\nexport function serializeSpecialReferenceValue(\n  features: number,\n  ref: SpecialReference,\n): string {\n  switch (ref) {\n    case SpecialReference.MapSentinel:\n      return '[]';\n    case SpecialReference.PromiseConstructor:\n      return serializePromiseConstructor(features);\n    case SpecialReference.PromiseSuccess:\n      return serializePromiseSuccess(features);\n    case SpecialReference.PromiseFailure:\n      return serializePromiseFailure(features);\n    case SpecialReference.StreamConstructor:\n      return serializeStreamConstructor(features);\n    default:\n      return '';\n  }\n}\n", "export interface Deferred {\n  promise: Promise<unknown>;\n  resolve(value: unknown): void;\n  reject(value: unknown): void;\n}\n\nexport function createDeferred(): Deferred {\n  let resolve: Deferred['resolve'];\n  let reject: Deferred['reject'];\n  return {\n    promise: new Promise<unknown>((res, rej) => {\n      resolve = res;\n      reject = rej;\n    }),\n    resolve(value): void {\n      resolve(value);\n    },\n    reject(value): void {\n      reject(value);\n    },\n  };\n}\n", "import type { Deferred } from './utils/deferred';\nimport { createDeferred } from './utils/deferred';\n\ninterface StreamListener<T> {\n  next(value: T): void;\n  throw(value: unknown): void;\n  return(value: T): void;\n}\n\nexport interface Stream<T> {\n  __SEROVAL_STREAM__: true;\n\n  on(listener: StreamListener<T>): () => void;\n\n  next(value: T): void;\n  throw(value: unknown): void;\n  return(value: T): void;\n}\n\nexport function isStream<T>(value: object): value is Stream<T> {\n  return '__SEROVAL_STREAM__' in value;\n}\n\nexport function createStream<T>(): Stream<T> {\n  const listeners = new Set<StreamListener<T>>();\n  const buffer: unknown[] = [];\n  let alive = true;\n  let success = true;\n\n  function flushNext(value: T): void {\n    for (const listener of listeners.keys()) {\n      listener.next(value);\n    }\n  }\n\n  function flushThrow(value: unknown): void {\n    for (const listener of listeners.keys()) {\n      listener.throw(value);\n    }\n  }\n\n  function flushReturn(value: T): void {\n    for (const listener of listeners.keys()) {\n      listener.return(value);\n    }\n  }\n\n  return {\n    __SEROVAL_STREAM__: true,\n    on(listener: StreamListener<T>): () => void {\n      if (alive) {\n        listeners.add(listener);\n      }\n      for (let i = 0, len = buffer.length; i < len; i++) {\n        const value = buffer[i];\n        if (i === len - 1 && !alive) {\n          if (success) {\n            listener.return(value as T);\n          } else {\n            listener.throw(value);\n          }\n        } else {\n          listener.next(value as T);\n        }\n      }\n      return () => {\n        if (alive) {\n          listeners.delete(listener);\n        }\n      };\n    },\n    next(value): void {\n      if (alive) {\n        buffer.push(value);\n        flushNext(value);\n      }\n    },\n    throw(value): void {\n      if (alive) {\n        buffer.push(value);\n        flushThrow(value);\n        alive = false;\n        success = false;\n        listeners.clear();\n      }\n    },\n    return(value): void {\n      if (alive) {\n        buffer.push(value);\n        flushReturn(value);\n        alive = false;\n        success = true;\n        listeners.clear();\n      }\n    },\n  };\n}\n\nexport function createStreamFromAsyncIterable<T>(\n  iterable: AsyncIterable<T>,\n): Stream<T> {\n  const stream = createStream<T>();\n\n  const iterator = iterable[Symbol.asyncIterator]();\n\n  async function push(): Promise<void> {\n    try {\n      const value = await iterator.next();\n      if (value.done) {\n        stream.return(value.value as T);\n      } else {\n        stream.next(value.value);\n        await push();\n      }\n    } catch (error) {\n      stream.throw(error);\n    }\n  }\n\n  push().catch(() => {\n    // no-op\n  });\n\n  return stream;\n}\n\nexport function streamToAsyncIterable<T>(\n  stream: Stream<T>,\n): () => AsyncIterableIterator<T> {\n  return (): AsyncIterableIterator<T> => {\n    const buffer: T[] = [];\n    const pending: Deferred[] = [];\n    let count = 0;\n    let doneAt = -1;\n    let isThrow = false;\n\n    function resolveAll(): void {\n      for (let i = 0, len = pending.length; i < len; i++) {\n        pending[i].resolve({ done: true, value: undefined });\n      }\n    }\n\n    stream.on({\n      next(value) {\n        const current = pending.shift();\n        if (current) {\n          current.resolve({ done: false, value });\n        }\n        buffer.push(value);\n      },\n      throw(value) {\n        const current = pending.shift();\n        if (current) {\n          current.reject(value);\n        }\n        resolveAll();\n        doneAt = buffer.length;\n        buffer.push(value as T);\n        isThrow = true;\n      },\n      return(value) {\n        const current = pending.shift();\n        if (current) {\n          current.resolve({ done: true, value });\n        }\n        resolveAll();\n        doneAt = buffer.length;\n        buffer.push(value);\n      },\n    });\n\n    function finalize() {\n      const current = count++;\n      const value = buffer[current];\n      if (current !== doneAt) {\n        return { done: false, value };\n      }\n      if (isThrow) {\n        throw value;\n      }\n      return { done: true, value };\n    }\n\n    return {\n      [Symbol.asyncIterator](): AsyncIterableIterator<T> {\n        return this;\n      },\n      async next(): Promise<IteratorResult<T>> {\n        if (doneAt === -1) {\n          const current = count++;\n          if (current >= buffer.length) {\n            const deferred = createDeferred();\n            pending.push(deferred);\n            return (await deferred.promise) as Promise<IteratorResult<T>>;\n          }\n          return { done: false, value: buffer[current] };\n        }\n        if (count > doneAt) {\n          return { done: true, value: undefined };\n        }\n        return finalize();\n      },\n    };\n  };\n}\n", "import { NIL } from \"../constants\";\n\nexport interface Sequence {\n  v: unknown[];\n  t: number;\n  d: number;\n}\n\nexport function iteratorToSequence<T>(source: Iterable<T>): Sequence {\n  const values: unknown[] = [];\n  let throwsAt = -1;\n  let doneAt = -1;\n\n  const iterator = source[Symbol.iterator]();\n\n  while (true) {\n    try {\n      const value = iterator.next();\n      values.push(value.value);\n      if (value.done) {\n        doneAt = values.length - 1;\n        break;\n      }\n    } catch (error) {\n      throwsAt = values.length;\n      values.push(error);\n    }\n  }\n\n  return {\n    v: values,\n    t: throwsAt,\n    d: doneAt,\n  };\n}\n\nexport function sequenceToIterator<T>(\n  sequence: Sequence,\n): () => IterableIterator<T> {\n  return (): IterableIterator<T> => {\n    let index = 0;\n\n    return {\n      [Symbol.iterator](): IterableIterator<T> {\n        return this;\n      },\n      next(): IteratorResult<T> {\n        if (index > sequence.d) {\n          return {\n            done: true,\n            value: NIL,\n          };\n        }\n        const currentIndex = index++;\n        const currentItem = sequence.v[currentIndex];\n        if (currentIndex === sequence.t) {\n          throw currentItem;\n        }\n        return {\n          done: currentIndex === sequence.d,\n          value: currentItem as T,\n        };\n      },\n    };\n  };\n}\n", "export default async function promiseToResult(\n  current: Promise<unknown>,\n): Promise<[0 | 1, unknown]> {\n  try {\n    return [1, await current];\n  } catch (e) {\n    return [0, e];\n  }\n}\n", "import {\n  createIndexedValueNode,\n  createReferenceNode,\n  createWKSymbolNode,\n} from '../base-primitives';\nimport { ALL_ENABLED } from '../compat';\nimport type { WellKnownSymbols } from '../constants';\nimport { INV_SYMBOL_REF, NIL, SerovalNodeType } from '../constants';\nimport { SerovalUnsupportedTypeError } from '../errors';\nimport { createSerovalNode } from '../node';\nimport type { Plugin, PluginAccessOptions, SerovalMode } from '../plugin';\nimport { hasReferenceID } from '../reference';\nimport {\n  ASYNC_ITERATOR,\n  ITERATOR,\n  SPECIAL_REFS,\n  SpecialReference,\n} from '../special-reference';\nimport type {\n  SerovalAsyncIteratorFactoryNode,\n  SerovalIndexedValueNode,\n  SerovalIteratorFactoryNode,\n  SerovalMapNode,\n  SerovalNode,\n  SerovalNullConstructorNode,\n  SerovalObjectNode,\n  SerovalObjectRecordNode,\n  SerovalPromiseConstructorNode,\n  SerovalReferenceNode,\n  SerovalSpecialReferenceNode,\n  SerovalWKSymbolNode,\n} from '../types';\nimport assert from '../utils/assert';\nimport { getObjectFlag } from '../utils/get-object-flag';\n\nexport interface BaseParserContextOptions extends PluginAccessOptions {\n  disabledFeatures?: number;\n  refs?: Map<unknown, number>;\n}\n\nexport const enum ParserNodeType {\n  Fresh = 0,\n  Indexed = 1,\n  Referenced = 2,\n}\n\nexport interface FreshNode {\n  type: ParserNodeType.Fresh;\n  value: number;\n}\n\nexport interface IndexedNode {\n  type: ParserNodeType.Indexed;\n  value: SerovalIndexedValueNode;\n}\n\nexport interface ReferencedNode {\n  type: ParserNodeType.Referenced;\n  value: SerovalReferenceNode;\n}\n\ntype ObjectNode = FreshNode | IndexedNode | ReferencedNode;\n\nexport abstract class BaseParserContext implements PluginAccessOptions {\n  abstract readonly mode: SerovalMode;\n\n  features: number;\n\n  marked = new Set<number>();\n\n  refs: Map<unknown, number>;\n\n  plugins?: Plugin<any, any>[] | undefined;\n\n  constructor(options: BaseParserContextOptions) {\n    this.plugins = options.plugins;\n    this.features = ALL_ENABLED ^ (options.disabledFeatures || 0);\n    this.refs = options.refs || new Map<unknown, number>();\n  }\n\n  protected markRef(id: number): void {\n    this.marked.add(id);\n  }\n\n  protected isMarked(id: number): boolean {\n    return this.marked.has(id);\n  }\n\n  protected createIndex<T>(current: T): number {\n    const id = this.refs.size;\n    this.refs.set(current, id);\n    return id;\n  }\n\n  protected getIndexedValue<T>(current: T): FreshNode | IndexedNode {\n    const registeredId = this.refs.get(current);\n    if (registeredId != null) {\n      this.markRef(registeredId);\n      return {\n        type: ParserNodeType.Indexed,\n        value: createIndexedValueNode(registeredId),\n      };\n    }\n    return {\n      type: ParserNodeType.Fresh,\n      value: this.createIndex(current),\n    };\n  }\n\n  protected getReference<T>(current: T): ObjectNode {\n    const indexed = this.getIndexedValue(current);\n    if (indexed.type === ParserNodeType.Indexed) {\n      return indexed;\n    }\n    if (hasReferenceID(current)) {\n      return {\n        type: ParserNodeType.Referenced,\n        value: createReferenceNode(indexed.value, current),\n      };\n    }\n    return indexed;\n  }\n\n  protected parseWellKnownSymbol(\n    current: symbol,\n  ): SerovalIndexedValueNode | SerovalWKSymbolNode | SerovalReferenceNode {\n    const ref = this.getReference(current);\n    if (ref.type !== ParserNodeType.Fresh) {\n      return ref.value;\n    }\n    assert(current in INV_SYMBOL_REF, new SerovalUnsupportedTypeError(current));\n    return createWKSymbolNode(ref.value, current as WellKnownSymbols);\n  }\n\n  protected parseSpecialReference(\n    ref: SpecialReference,\n  ): SerovalIndexedValueNode | SerovalSpecialReferenceNode {\n    const result = this.getIndexedValue(SPECIAL_REFS[ref]);\n    if (result.type === ParserNodeType.Indexed) {\n      return result.value;\n    }\n    return createSerovalNode(\n      SerovalNodeType.SpecialReference,\n      result.value,\n      ref,\n      NIL,\n      NIL,\n      NIL,\n      NIL,\n      NIL,\n      NIL,\n      NIL,\n      NIL,\n      NIL,\n    );\n  }\n\n  protected parseIteratorFactory():\n    | SerovalIndexedValueNode\n    | SerovalIteratorFactoryNode {\n    const result = this.getIndexedValue(ITERATOR);\n    if (result.type === ParserNodeType.Indexed) {\n      return result.value;\n    }\n    return createSerovalNode(\n      SerovalNodeType.IteratorFactory,\n      result.value,\n      NIL,\n      NIL,\n      NIL,\n      NIL,\n      NIL,\n      NIL,\n      NIL,\n      this.parseWellKnownSymbol(Symbol.iterator),\n      NIL,\n      NIL,\n    );\n  }\n\n  protected parseAsyncIteratorFactory():\n    | SerovalIndexedValueNode\n    | SerovalAsyncIteratorFactoryNode {\n    const result = this.getIndexedValue(ASYNC_ITERATOR);\n    if (result.type === ParserNodeType.Indexed) {\n      return result.value;\n    }\n    return createSerovalNode(\n      SerovalNodeType.AsyncIteratorFactory,\n      result.value,\n      NIL,\n      NIL,\n      NIL,\n      NIL,\n      NIL,\n      NIL,\n      [\n        this.parseSpecialReference(SpecialReference.PromiseConstructor),\n        this.parseWellKnownSymbol(Symbol.asyncIterator),\n      ],\n      NIL,\n      NIL,\n      NIL,\n    );\n  }\n\n  protected createObjectNode(\n    id: number,\n    current: Record<string, unknown>,\n    empty: boolean,\n    record: SerovalObjectRecordNode,\n  ): SerovalObjectNode | SerovalNullConstructorNode {\n    return createSerovalNode(\n      empty ? SerovalNodeType.NullConstructor : SerovalNodeType.Object,\n      id,\n      NIL,\n      NIL,\n      NIL,\n      NIL,\n      record,\n      NIL,\n      NIL,\n      NIL,\n      NIL,\n      getObjectFlag(current),\n    );\n  }\n\n  protected createMapNode(\n    id: number,\n    k: SerovalNode[],\n    v: SerovalNode[],\n    s: number,\n  ): SerovalMapNode {\n    return createSerovalNode(\n      SerovalNodeType.Map,\n      id,\n      NIL,\n      NIL,\n      NIL,\n      NIL,\n      NIL,\n      { k, v, s },\n      NIL,\n      this.parseSpecialReference(SpecialReference.MapSentinel),\n      NIL,\n      NIL,\n    );\n  }\n\n  protected createPromiseConstructorNode(\n    id: number,\n    resolver: number,\n  ): SerovalPromiseConstructorNode {\n    return createSerovalNode(\n      SerovalNodeType.PromiseConstructor,\n      id,\n      resolver,\n      NIL,\n      NIL,\n      NIL,\n      NIL,\n      NIL,\n      NIL,\n      this.parseSpecialReference(SpecialReference.PromiseConstructor),\n      NIL,\n      NIL,\n    );\n  }\n}\n", "import {\n  createAggregateErrorNode,\n  createArrayBufferNode,\n  createArrayNode,\n  createAsyncIteratorFactoryInstanceNode,\n  createBigIntNode,\n  createBigIntTypedArrayNode,\n  createBoxedNode,\n  createDataViewNode,\n  createDateNode,\n  createErrorNode,\n  createIteratorFactoryInstanceNode,\n  createNumberNode,\n  createPluginNode,\n  createRegExpNode,\n  createSetNode,\n  createStreamConstructorNode,\n  createStreamNextNode,\n  createStreamReturnNode,\n  createStreamThrowNode,\n  createStringNode,\n  createTypedArrayNode,\n} from '../../base-primitives';\nimport { Feature } from '../../compat';\nimport { NIL, SerovalNodeType } from '../../constants';\nimport { SerovalParserError, SerovalUnsupportedTypeError } from '../../errors';\nimport {\n  FALSE_NODE,\n  NULL_NODE,\n  TRUE_NODE,\n  UNDEFINED_NODE,\n} from '../../literals';\nimport { createSerovalNode } from '../../node';\nimport { OpaqueReference } from '../../opaque-reference';\nimport { SpecialReference } from '../../special-reference';\nimport type { Stream } from '../../stream';\nimport { createStreamFromAsyncIterable, isStream } from '../../stream';\nimport { serializeString } from '../../string';\nimport type {\n  SerovalAggregateErrorNode,\n  SerovalArrayNode,\n  SerovalBigIntTypedArrayNode,\n  SerovalBoxedNode,\n  SerovalDataViewNode,\n  SerovalErrorNode,\n  SerovalMapNode,\n  SerovalNode,\n  SerovalNullConstructorNode,\n  SerovalObjectNode,\n  SerovalObjectRecordKey,\n  SerovalObjectRecordNode,\n  SerovalPluginNode,\n  SerovalPromiseNode,\n  SerovalSetNode,\n  SerovalStreamConstructorNode,\n  SerovalTypedArrayNode,\n} from '../../types';\nimport { getErrorOptions } from '../../utils/error';\nimport { iteratorToSequence } from '../../utils/iterator-to-sequence';\nimport promiseToResult from '../../utils/promise-to-result';\nimport type {\n  BigIntTypedArrayValue,\n  TypedArrayValue,\n} from '../../utils/typed-array';\nimport { BaseParserContext, ParserNodeType } from '../parser';\n\ntype ObjectLikeNode =\n  | SerovalObjectNode\n  | SerovalNullConstructorNode\n  | SerovalPromiseNode;\n\nexport default abstract class BaseAsyncParserContext extends BaseParserContext {\n  private async parseItems(current: unknown[]): Promise<SerovalNode[]> {\n    const nodes = [];\n    for (let i = 0, len = current.length; i < len; i++) {\n      // For consistency in holes\n      if (i in current) {\n        nodes[i] = await this.parse(current[i]);\n      }\n    }\n    return nodes;\n  }\n\n  private async parseArray(\n    id: number,\n    current: unknown[],\n  ): Promise<SerovalArrayNode> {\n    return createArrayNode(id, current, await this.parseItems(current));\n  }\n\n  private async parseProperties(\n    properties: Record<string | symbol, unknown>,\n  ): Promise<SerovalObjectRecordNode> {\n    const entries = Object.entries(properties);\n    const keyNodes: SerovalObjectRecordKey[] = [];\n    const valueNodes: SerovalNode[] = [];\n    for (let i = 0, len = entries.length; i < len; i++) {\n      keyNodes.push(serializeString(entries[i][0]));\n      valueNodes.push(await this.parse(entries[i][1]));\n    }\n    // Check special properties\n    let symbol = Symbol.iterator;\n    if (symbol in properties) {\n      keyNodes.push(this.parseWellKnownSymbol(symbol));\n      valueNodes.push(\n        createIteratorFactoryInstanceNode(\n          this.parseIteratorFactory(),\n          await this.parse(\n            iteratorToSequence(properties as unknown as Iterable<unknown>),\n          ),\n        ),\n      );\n    }\n    symbol = Symbol.asyncIterator;\n    if (symbol in properties) {\n      keyNodes.push(this.parseWellKnownSymbol(symbol));\n      valueNodes.push(\n        createAsyncIteratorFactoryInstanceNode(\n          this.parseAsyncIteratorFactory(),\n          await this.parse(\n            createStreamFromAsyncIterable(\n              properties as unknown as AsyncIterable<unknown>,\n            ),\n          ),\n        ),\n      );\n    }\n    symbol = Symbol.toStringTag;\n    if (symbol in properties) {\n      keyNodes.push(this.parseWellKnownSymbol(symbol));\n      valueNodes.push(createStringNode(properties[symbol] as string));\n    }\n    symbol = Symbol.isConcatSpreadable;\n    if (symbol in properties) {\n      keyNodes.push(this.parseWellKnownSymbol(symbol));\n      valueNodes.push(properties[symbol] ? TRUE_NODE : FALSE_NODE);\n    }\n    return {\n      k: keyNodes,\n      v: valueNodes,\n      s: keyNodes.length,\n    };\n  }\n\n  private async parsePlainObject(\n    id: number,\n    current: Record<string, unknown>,\n    empty: boolean,\n  ): Promise<ObjectLikeNode> {\n    return this.createObjectNode(\n      id,\n      current,\n      empty,\n      await this.parseProperties(current),\n    );\n  }\n\n  private async parseBoxed(\n    id: number,\n    current: object,\n  ): Promise<SerovalBoxedNode> {\n    return createBoxedNode(id, await this.parse(current.valueOf()));\n  }\n\n  private async parseTypedArray(\n    id: number,\n    current: TypedArrayValue,\n  ): Promise<SerovalTypedArrayNode> {\n    return createTypedArrayNode(id, current, await this.parse(current.buffer));\n  }\n\n  private async parseBigIntTypedArray(\n    id: number,\n    current: BigIntTypedArrayValue,\n  ): Promise<SerovalBigIntTypedArrayNode> {\n    return createBigIntTypedArrayNode(\n      id,\n      current,\n      await this.parse(current.buffer),\n    );\n  }\n\n  private async parseDataView(\n    id: number,\n    current: DataView,\n  ): Promise<SerovalDataViewNode> {\n    return createDataViewNode(id, current, await this.parse(current.buffer));\n  }\n\n  private async parseError(\n    id: number,\n    current: Error,\n  ): Promise<SerovalErrorNode> {\n    const options = getErrorOptions(current, this.features);\n    return createErrorNode(\n      id,\n      current,\n      options ? await this.parseProperties(options) : NIL,\n    );\n  }\n\n  private async parseAggregateError(\n    id: number,\n    current: AggregateError,\n  ): Promise<SerovalAggregateErrorNode> {\n    const options = getErrorOptions(current, this.features);\n    return createAggregateErrorNode(\n      id,\n      current,\n      options ? await this.parseProperties(options) : NIL,\n    );\n  }\n\n  private async parseMap(\n    id: number,\n    current: Map<unknown, unknown>,\n  ): Promise<SerovalMapNode> {\n    const keyNodes: SerovalNode[] = [];\n    const valueNodes: SerovalNode[] = [];\n    for (const [key, value] of current.entries()) {\n      keyNodes.push(await this.parse(key));\n      valueNodes.push(await this.parse(value));\n    }\n    return this.createMapNode(id, keyNodes, valueNodes, current.size);\n  }\n\n  private async parseSet(\n    id: number,\n    current: Set<unknown>,\n  ): Promise<SerovalSetNode> {\n    const items: SerovalNode[] = [];\n    for (const item of current.keys()) {\n      items.push(await this.parse(item));\n    }\n    return createSetNode(id, current.size, items);\n  }\n\n  private async parsePromise(\n    id: number,\n    current: Promise<unknown>,\n  ): Promise<SerovalPromiseNode> {\n    const [status, result] = await promiseToResult(current);\n\n    return createSerovalNode(\n      SerovalNodeType.Promise,\n      id,\n      status,\n      NIL,\n      NIL,\n      NIL,\n      NIL,\n      NIL,\n      NIL,\n      await this.parse(result),\n      NIL,\n      NIL,\n    );\n  }\n\n  private async parsePlugin(\n    id: number,\n    current: unknown,\n  ): Promise<SerovalPluginNode | undefined> {\n    const currentPlugins = this.plugins;\n    if (currentPlugins) {\n      for (let i = 0, len = currentPlugins.length; i < len; i++) {\n        const plugin = currentPlugins[i];\n        if (plugin.parse.async && plugin.test(current)) {\n          return createPluginNode(\n            id,\n            plugin.tag,\n            await plugin.parse.async(current, this, {\n              id,\n            }),\n          );\n        }\n      }\n    }\n    return NIL;\n  }\n\n  private async parseStream(\n    id: number,\n    current: Stream<unknown>,\n  ): Promise<SerovalStreamConstructorNode> {\n    return createStreamConstructorNode(\n      id,\n      this.parseSpecialReference(SpecialReference.StreamConstructor),\n      await new Promise<SerovalNode[]>((resolve, reject) => {\n        const sequence: SerovalNode[] = [];\n        const cleanup = current.on({\n          next: value => {\n            this.markRef(id);\n            this.parse(value).then(\n              data => {\n                sequence.push(createStreamNextNode(id, data));\n              },\n              data => {\n                reject(data);\n                cleanup();\n              },\n            );\n          },\n          throw: value => {\n            this.markRef(id);\n            this.parse(value).then(\n              data => {\n                sequence.push(createStreamThrowNode(id, data));\n                resolve(sequence);\n                cleanup();\n              },\n              data => {\n                reject(data);\n                cleanup();\n              },\n            );\n          },\n          return: value => {\n            this.markRef(id);\n            this.parse(value).then(\n              data => {\n                sequence.push(createStreamReturnNode(id, data));\n                resolve(sequence);\n                cleanup();\n              },\n              data => {\n                reject(data);\n                cleanup();\n              },\n            );\n          },\n        });\n      }),\n    );\n  }\n\n  // biome-ignore lint/complexity/noExcessiveCognitiveComplexity: ehh\n  private async parseObject(id: number, current: object): Promise<SerovalNode> {\n    if (Array.isArray(current)) {\n      return this.parseArray(id, current);\n    }\n    if (isStream(current)) {\n      return this.parseStream(id, current);\n    }\n    const currentClass = current.constructor;\n    if (currentClass === OpaqueReference) {\n      return this.parse(\n        (current as OpaqueReference<unknown, unknown>).replacement,\n      );\n    }\n    const parsed = await this.parsePlugin(id, current);\n    if (parsed) {\n      return parsed;\n    }\n    switch (currentClass) {\n      case Object:\n        return this.parsePlainObject(\n          id,\n          current as Record<string, unknown>,\n          false,\n        );\n      case NIL:\n        return this.parsePlainObject(\n          id,\n          current as Record<string, unknown>,\n          true,\n        );\n      case Date:\n        return createDateNode(id, current as unknown as Date);\n      case RegExp:\n        return createRegExpNode(id, current as unknown as RegExp);\n      case Error:\n      case EvalError:\n      case RangeError:\n      case ReferenceError:\n      case SyntaxError:\n      case TypeError:\n      case URIError:\n        return this.parseError(id, current as unknown as Error);\n      case Number:\n      case Boolean:\n      case String:\n      case BigInt:\n        return this.parseBoxed(id, current);\n      case ArrayBuffer:\n        return createArrayBufferNode(id, current as unknown as ArrayBuffer);\n      case Int8Array:\n      case Int16Array:\n      case Int32Array:\n      case Uint8Array:\n      case Uint16Array:\n      case Uint32Array:\n      case Uint8ClampedArray:\n      case Float32Array:\n      case Float64Array:\n        return this.parseTypedArray(id, current as unknown as TypedArrayValue);\n      case DataView:\n        return this.parseDataView(id, current as unknown as DataView);\n      case Map:\n        return this.parseMap(id, current as unknown as Map<unknown, unknown>);\n      case Set:\n        return this.parseSet(id, current as unknown as Set<unknown>);\n      default:\n        break;\n    }\n    // Promises\n    if (currentClass === Promise || current instanceof Promise) {\n      return this.parsePromise(id, current as unknown as Promise<unknown>);\n    }\n    const currentFeatures = this.features;\n    // BigInt Typed Arrays\n    if (currentFeatures & Feature.BigIntTypedArray) {\n      switch (currentClass) {\n        case BigInt64Array:\n        case BigUint64Array:\n          return this.parseBigIntTypedArray(\n            id,\n            current as unknown as BigIntTypedArrayValue,\n          );\n        default:\n          break;\n      }\n    }\n    if (\n      currentFeatures & Feature.AggregateError &&\n      typeof AggregateError !== 'undefined' &&\n      (currentClass === AggregateError || current instanceof AggregateError)\n    ) {\n      return this.parseAggregateError(id, current as unknown as AggregateError);\n    }\n    // Slow path. We only need to handle Errors and Iterators\n    // since they have very broad implementations.\n    if (current instanceof Error) {\n      return this.parseError(id, current);\n    }\n    // Generator functions don't have a global constructor\n    // despite existing\n    if (Symbol.iterator in current || Symbol.asyncIterator in current) {\n      return this.parsePlainObject(id, current, !!currentClass);\n    }\n    throw new SerovalUnsupportedTypeError(current);\n  }\n\n  protected async parseFunction(current: unknown): Promise<SerovalNode> {\n    const ref = this.getReference(current);\n    if (ref.type !== ParserNodeType.Fresh) {\n      return ref.value;\n    }\n    const plugin = await this.parsePlugin(ref.value, current);\n    if (plugin) {\n      return plugin;\n    }\n    throw new SerovalUnsupportedTypeError(current);\n  }\n\n  async parse<T>(current: T): Promise<SerovalNode> {\n    switch (typeof current) {\n      case 'boolean':\n        return current ? TRUE_NODE : FALSE_NODE;\n      case 'undefined':\n        return UNDEFINED_NODE;\n      case 'string':\n        return createStringNode(current as string);\n      case 'number':\n        return createNumberNode(current as number);\n      case 'bigint':\n        return createBigIntNode(current as bigint);\n      case 'object': {\n        if (current) {\n          const ref = this.getReference(current);\n          return ref.type === 0\n            ? await this.parseObject(ref.value, current as object)\n            : ref.value;\n        }\n        return NULL_NODE;\n      }\n      case 'symbol':\n        return this.parseWellKnownSymbol(current);\n      case 'function':\n        return this.parseFunction(current);\n      default:\n        throw new SerovalUnsupportedTypeError(current);\n    }\n  }\n\n  async parseTop<T>(current: T): Promise<SerovalNode> {\n    try {\n      return await this.parse(current);\n    } catch (error) {\n      throw error instanceof SerovalParserError\n        ? error\n        : new SerovalParserError(error);\n    }\n  }\n}\n", "import BaseAsyncParserContext from '../context/parser/async';\nimport type { SerovalMode } from '../plugin';\nimport type { CrossParserContextOptions } from './parser';\n\nexport type CrossAsyncParserContextOptions = CrossParserContextOptions;\n\nexport default class CrossAsyncParserContext extends BaseAsyncParserContext {\n  readonly mode: SerovalMode = 'cross';\n}\n", "import { SerovalUnknownTypedArrayError } from '../errors';\n\ntype TypedArrayConstructor =\n  | Int8ArrayConstructor\n  | Int16ArrayConstructor\n  | Int32ArrayConstructor\n  | Uint8ArrayConstructor\n  | Uint16ArrayConstructor\n  | Uint32ArrayConstructor\n  | Uint8ClampedArrayConstructor\n  | Float32ArrayConstructor\n  | Float64ArrayConstructor\n  | BigInt64ArrayConstructor\n  | BigUint64ArrayConstructor;\n\nexport type TypedArrayValue =\n  | Int8Array\n  | Int16Array\n  | Int32Array\n  | Uint8Array\n  | Uint16Array\n  | Uint32Array\n  | Uint8ClampedArray\n  | Float32Array\n  | Float64Array;\n\nexport type BigIntTypedArrayValue = BigInt64Array | BigUint64Array;\n\nexport function getTypedArrayConstructor(name: string): TypedArrayConstructor {\n  switch (name) {\n    case 'Int8Array':\n      return Int8Array;\n    case 'Int16Array':\n      return Int16Array;\n    case 'Int32Array':\n      return Int32Array;\n    case 'Uint8Array':\n      return Uint8Array;\n    case 'Uint16Array':\n      return Uint16Array;\n    case 'Uint32Array':\n      return Uint32Array;\n    case 'Uint8ClampedArray':\n      return Uint8ClampedArray;\n    case 'Float32Array':\n      return Float32Array;\n    case 'Float64Array':\n      return Float64Array;\n    case 'BigInt64Array':\n      return BigInt64Array;\n    case 'BigUint64Array':\n      return BigUint64Array;\n    default:\n      throw new SerovalUnknownTypedArrayError(name);\n  }\n}\n", "import {\n  CONSTANT_VAL,\n  ERROR_CONSTRUCTOR,\n  SYMBOL_REF,\n  SerovalNodeType,\n  SerovalObjectFlags,\n} from '../constants';\nimport {\n  SerovalDeserializationError,\n  SerovalMissingInstanceError,\n  SerovalMissingPluginError,\n  SerovalUnsupportedNodeError,\n} from '../errors';\nimport type { Plugin, PluginAccessOptions, SerovalMode } from '../plugin';\nimport { getReference } from '../reference';\nimport type { Stream } from '../stream';\nimport { createStream, streamToAsyncIterable } from '../stream';\nimport { deserializeString } from '../string';\nimport type {\n  SerovalAggregateErrorNode,\n  SerovalArrayBufferNode,\n  SerovalArrayNode,\n  SerovalAsyncIteratorFactoryInstanceNode,\n  SerovalAsyncIteratorFactoryNode,\n  SerovalBigIntTypedArrayNode,\n  SerovalBoxedNode,\n  SerovalDataViewNode,\n  SerovalDateNode,\n  SerovalErrorNode,\n  SerovalIteratorFactoryInstanceNode,\n  SerovalIteratorFactoryNode,\n  SerovalMapNode,\n  SerovalNode,\n  SerovalNullConstructorNode,\n  SerovalObjectNode,\n  SerovalObjectRecordKey,\n  SerovalObjectRecordNode,\n  SerovalPluginNode,\n  SerovalPromiseConstructorNode,\n  SerovalPromiseNode,\n  SerovalPromiseRejectNode,\n  SerovalPromiseResolveNode,\n  SerovalReferenceNode,\n  SerovalRegExpNode,\n  SerovalSetNode,\n  SerovalStreamConstructorNode,\n  SerovalStreamNextNode,\n  SerovalStreamReturnNode,\n  SerovalStreamThrowNode,\n  SerovalTypedArrayNode,\n} from '../types';\nimport assert from '../utils/assert';\nimport type { Deferred } from '../utils/deferred';\nimport { createDeferred } from '../utils/deferred';\nimport type { Sequence } from '../utils/iterator-to-sequence';\nimport { sequenceToIterator } from '../utils/iterator-to-sequence';\nimport type {\n  BigIntTypedArrayValue,\n  TypedArrayValue,\n} from '../utils/typed-array';\nimport { getTypedArrayConstructor } from '../utils/typed-array';\n\nfunction applyObjectFlag(obj: unknown, flag: SerovalObjectFlags): unknown {\n  switch (flag) {\n    case SerovalObjectFlags.Frozen:\n      return Object.freeze(obj);\n    case SerovalObjectFlags.NonExtensible:\n      return Object.preventExtensions(obj);\n    case SerovalObjectFlags.Sealed:\n      return Object.seal(obj);\n    default:\n      return obj;\n  }\n}\n\ntype AssignableValue = AggregateError | Error | Iterable<unknown>;\ntype AssignableNode = SerovalAggregateErrorNode | SerovalErrorNode;\n\nexport interface BaseDeserializerOptions extends PluginAccessOptions {\n  refs?: Map<number, unknown>;\n}\n\nexport default abstract class BaseDeserializerContext\n  implements PluginAccessOptions\n{\n  abstract readonly mode: SerovalMode;\n\n  /**\n   * Mapping ids to values\n   * @private\n   */\n  refs: Map<number, unknown>;\n\n  plugins?: Plugin<any, any>[] | undefined;\n\n  constructor(options: BaseDeserializerOptions) {\n    this.plugins = options.plugins;\n    this.refs = options.refs || new Map<number, unknown>();\n  }\n\n  protected abstract assignIndexedValue<T>(id: number, value: T): T;\n\n  private deserializeReference(node: SerovalReferenceNode): unknown {\n    return this.assignIndexedValue(\n      node.i,\n      getReference(deserializeString(node.s)),\n    );\n  }\n\n  private deserializeArray(node: SerovalArrayNode): unknown[] {\n    const len = node.l;\n    const result: unknown[] = this.assignIndexedValue(\n      node.i,\n      new Array<unknown>(len),\n    );\n    let item: SerovalNode | undefined;\n    for (let i = 0; i < len; i++) {\n      item = node.a[i];\n      if (item) {\n        result[i] = this.deserialize(item);\n      }\n    }\n    applyObjectFlag(result, node.o);\n    return result;\n  }\n\n  private deserializeProperties(\n    node: SerovalObjectRecordNode,\n    result: Record<string | symbol, unknown>,\n  ): Record<string | symbol, unknown> {\n    const len = node.s;\n    if (len) {\n      const keys = node.k;\n      const vals = node.v;\n      for (let i = 0, key: SerovalObjectRecordKey; i < len; i++) {\n        key = keys[i];\n        if (typeof key === 'string') {\n          result[deserializeString(key)] = this.deserialize(vals[i]);\n        } else {\n          result[this.deserialize(key) as symbol] = this.deserialize(vals[i]);\n        }\n      }\n    }\n    return result;\n  }\n\n  private deserializeObject(\n    node: SerovalObjectNode | SerovalNullConstructorNode,\n  ): Record<string, unknown> {\n    const result = this.assignIndexedValue(\n      node.i,\n      (node.t === SerovalNodeType.Object ? {} : Object.create(null)) as Record<\n        string,\n        unknown\n      >,\n    );\n    this.deserializeProperties(node.p, result);\n    applyObjectFlag(result, node.o);\n    return result;\n  }\n\n  private deserializeDate(node: SerovalDateNode): Date {\n    return this.assignIndexedValue(node.i, new Date(node.s));\n  }\n\n  private deserializeRegExp(node: SerovalRegExpNode): RegExp {\n    return this.assignIndexedValue(\n      node.i,\n      new RegExp(deserializeString(node.c), node.m),\n    );\n  }\n\n  private deserializeSet(node: SerovalSetNode): Set<unknown> {\n    const result = this.assignIndexedValue(node.i, new Set<unknown>());\n    const items = node.a;\n    for (let i = 0, len = node.l; i < len; i++) {\n      result.add(this.deserialize(items[i]));\n    }\n    return result;\n  }\n\n  private deserializeMap(node: SerovalMapNode): Map<unknown, unknown> {\n    const result = this.assignIndexedValue(node.i, new Map<unknown, unknown>());\n    const keys = node.e.k;\n    const vals = node.e.v;\n    for (let i = 0, len = node.e.s; i < len; i++) {\n      result.set(this.deserialize(keys[i]), this.deserialize(vals[i]));\n    }\n    return result;\n  }\n\n  private deserializeArrayBuffer(node: SerovalArrayBufferNode): ArrayBuffer {\n    const bytes = new Uint8Array(node.s);\n    const result = this.assignIndexedValue(node.i, bytes.buffer);\n    return result;\n  }\n\n  private deserializeTypedArray(\n    node: SerovalTypedArrayNode | SerovalBigIntTypedArrayNode,\n  ): TypedArrayValue | BigIntTypedArrayValue {\n    const construct = getTypedArrayConstructor(node.c) as Int8ArrayConstructor;\n    const source = this.deserialize(node.f) as ArrayBuffer;\n    const result = this.assignIndexedValue(\n      node.i,\n      new construct(source, node.b, node.l),\n    );\n    return result;\n  }\n\n  private deserializeDataView(node: SerovalDataViewNode): DataView {\n    const source = this.deserialize(node.f) as ArrayBuffer;\n    const result = this.assignIndexedValue(\n      node.i,\n      new DataView(source, node.b, node.l),\n    );\n    return result;\n  }\n\n  private deserializeDictionary<T extends AssignableValue>(\n    node: AssignableNode,\n    result: T,\n  ): T {\n    if (node.p) {\n      const fields = this.deserializeProperties(node.p, {});\n      Object.assign(result, fields);\n    }\n    return result;\n  }\n\n  private deserializeAggregateError(\n    node: SerovalAggregateErrorNode,\n  ): AggregateError {\n    // Serialize the required arguments\n    const result = this.assignIndexedValue(\n      node.i,\n      new AggregateError([], deserializeString(node.m)),\n    );\n    // `AggregateError` might've been extended\n    // either through class or custom properties\n    // Make sure to assign extra properties\n    return this.deserializeDictionary(node, result);\n  }\n\n  private deserializeError(node: SerovalErrorNode): Error {\n    const construct = ERROR_CONSTRUCTOR[node.s];\n    const result = this.assignIndexedValue(\n      node.i,\n      new construct(deserializeString(node.m)),\n    );\n    return this.deserializeDictionary(node, result);\n  }\n\n  private deserializePromise(node: SerovalPromiseNode): Promise<unknown> {\n    const deferred = createDeferred();\n    const result = this.assignIndexedValue(node.i, deferred);\n    const deserialized = this.deserialize(node.f);\n    if (node.s) {\n      deferred.resolve(deserialized);\n    } else {\n      deferred.reject(deserialized);\n    }\n    return result.promise;\n  }\n\n  private deserializeBoxed(node: SerovalBoxedNode): unknown {\n    return this.assignIndexedValue(node.i, Object(this.deserialize(node.f)));\n  }\n\n  private deserializePlugin(node: SerovalPluginNode): unknown {\n    const currentPlugins = this.plugins;\n    if (currentPlugins) {\n      const tag = deserializeString(node.c);\n      for (let i = 0, len = currentPlugins.length; i < len; i++) {\n        const plugin = currentPlugins[i];\n        if (plugin.tag === tag) {\n          return this.assignIndexedValue(\n            node.i,\n            plugin.deserialize(node.s, this, {\n              id: node.i,\n            }),\n          );\n        }\n      }\n    }\n    throw new SerovalMissingPluginError(node.c);\n  }\n\n  private deserializePromiseConstructor(\n    node: SerovalPromiseConstructorNode,\n  ): unknown {\n    return this.assignIndexedValue(\n      node.i,\n      this.assignIndexedValue(node.s, createDeferred()).promise,\n    );\n  }\n\n  private deserializePromiseResolve(node: SerovalPromiseResolveNode): unknown {\n    const deferred = this.refs.get(node.i) as Deferred | undefined;\n    assert(deferred, new SerovalMissingInstanceError('Promise'));\n    deferred.resolve(this.deserialize(node.a[1]));\n    return undefined;\n  }\n\n  private deserializePromiseReject(node: SerovalPromiseRejectNode): unknown {\n    const deferred = this.refs.get(node.i) as Deferred | undefined;\n    assert(deferred, new SerovalMissingInstanceError('Promise'));\n    deferred.reject(this.deserialize(node.a[1]));\n    return undefined;\n  }\n\n  private deserializeIteratorFactoryInstance(\n    node: SerovalIteratorFactoryInstanceNode,\n  ): unknown {\n    this.deserialize(node.a[0]);\n    const source = this.deserialize(node.a[1]);\n    return sequenceToIterator(source as Sequence);\n  }\n\n  private deserializeAsyncIteratorFactoryInstance(\n    node: SerovalAsyncIteratorFactoryInstanceNode,\n  ): unknown {\n    this.deserialize(node.a[0]);\n    const source = this.deserialize(node.a[1]);\n    return streamToAsyncIterable(source as Stream<any>);\n  }\n\n  private deserializeStreamConstructor(\n    node: SerovalStreamConstructorNode,\n  ): unknown {\n    const result = this.assignIndexedValue(node.i, createStream());\n    const len = node.a.length;\n    if (len) {\n      for (let i = 0; i < len; i++) {\n        this.deserialize(node.a[i]);\n      }\n    }\n    return result;\n  }\n\n  private deserializeStreamNext(node: SerovalStreamNextNode): unknown {\n    const deferred = this.refs.get(node.i) as Stream<unknown> | undefined;\n    assert(deferred, new SerovalMissingInstanceError('Stream'));\n    deferred.next(this.deserialize(node.f));\n    return undefined;\n  }\n\n  private deserializeStreamThrow(node: SerovalStreamThrowNode): unknown {\n    const deferred = this.refs.get(node.i) as Stream<unknown> | undefined;\n    assert(deferred, new SerovalMissingInstanceError('Stream'));\n    deferred.throw(this.deserialize(node.f));\n    return undefined;\n  }\n\n  private deserializeStreamReturn(node: SerovalStreamReturnNode): unknown {\n    const deferred = this.refs.get(node.i) as Stream<unknown> | undefined;\n    assert(deferred, new SerovalMissingInstanceError('Stream'));\n    deferred.return(this.deserialize(node.f));\n    return undefined;\n  }\n\n  private deserializeIteratorFactory(\n    node: SerovalIteratorFactoryNode,\n  ): unknown {\n    this.deserialize(node.f);\n    return undefined;\n  }\n\n  private deserializeAsyncIteratorFactory(\n    node: SerovalAsyncIteratorFactoryNode,\n  ): unknown {\n    this.deserialize(node.a[1]);\n    return undefined;\n  }\n\n  deserializeTop(node: SerovalNode): unknown {\n    try {\n      return this.deserialize(node);\n    } catch (error) {\n      throw new SerovalDeserializationError(error);\n    }\n  }\n\n  deserialize(node: SerovalNode): unknown {\n    switch (node.t) {\n      case SerovalNodeType.Constant:\n        return CONSTANT_VAL[node.s];\n      case SerovalNodeType.Number:\n        return node.s;\n      case SerovalNodeType.String:\n        return deserializeString(node.s);\n      case SerovalNodeType.BigInt:\n        return BigInt(node.s);\n      case SerovalNodeType.IndexedValue:\n        return this.refs.get(node.i);\n      case SerovalNodeType.Reference:\n        return this.deserializeReference(node);\n      case SerovalNodeType.Array:\n        return this.deserializeArray(node);\n      case SerovalNodeType.Object:\n      case SerovalNodeType.NullConstructor:\n        return this.deserializeObject(node);\n      case SerovalNodeType.Date:\n        return this.deserializeDate(node);\n      case SerovalNodeType.RegExp:\n        return this.deserializeRegExp(node);\n      case SerovalNodeType.Set:\n        return this.deserializeSet(node);\n      case SerovalNodeType.Map:\n        return this.deserializeMap(node);\n      case SerovalNodeType.ArrayBuffer:\n        return this.deserializeArrayBuffer(node);\n      case SerovalNodeType.BigIntTypedArray:\n      case SerovalNodeType.TypedArray:\n        return this.deserializeTypedArray(node);\n      case SerovalNodeType.DataView:\n        return this.deserializeDataView(node);\n      case SerovalNodeType.AggregateError:\n        return this.deserializeAggregateError(node);\n      case SerovalNodeType.Error:\n        return this.deserializeError(node);\n      case SerovalNodeType.Promise:\n        return this.deserializePromise(node);\n      case SerovalNodeType.WKSymbol:\n        return SYMBOL_REF[node.s];\n      case SerovalNodeType.Boxed:\n        return this.deserializeBoxed(node);\n      case SerovalNodeType.Plugin:\n        return this.deserializePlugin(node);\n      case SerovalNodeType.PromiseConstructor:\n        return this.deserializePromiseConstructor(node);\n      case SerovalNodeType.PromiseSuccess:\n        return this.deserializePromiseResolve(node);\n      case SerovalNodeType.PromiseFailure:\n        return this.deserializePromiseReject(node);\n      case SerovalNodeType.IteratorFactoryInstance:\n        return this.deserializeIteratorFactoryInstance(node);\n      case SerovalNodeType.AsyncIteratorFactoryInstance:\n        return this.deserializeAsyncIteratorFactoryInstance(node);\n      case SerovalNodeType.StreamConstructor:\n        return this.deserializeStreamConstructor(node);\n      case SerovalNodeType.StreamNext:\n        return this.deserializeStreamNext(node);\n      case SerovalNodeType.StreamThrow:\n        return this.deserializeStreamThrow(node);\n      case SerovalNodeType.StreamReturn:\n        return this.deserializeStreamReturn(node);\n      case SerovalNodeType.IteratorFactory:\n        return this.deserializeIteratorFactory(node);\n      case SerovalNodeType.AsyncIteratorFactory:\n        return this.deserializeAsyncIteratorFactory(node);\n      // case SerovalNodeType.SpecialReference:\n      default:\n        throw new SerovalUnsupportedNodeError(node);\n    }\n  }\n}\n", "import type { BaseDeserializerOptions } from '../context/deserializer';\nimport BaseDeserializerContext from '../context/deserializer';\nimport type { SerovalMode } from '../plugin';\n\nexport type CrossDeserializerContextOptions = BaseDeserializerOptions;\n\nexport default class CrossDeserializerContext extends BaseDeserializerContext {\n  readonly mode: SerovalMode = 'cross';\n\n  assignIndexedValue<T>(index: number, value: T): T {\n    if (!this.refs.has(index)) {\n      this.refs.set(index, value);\n    }\n    return value;\n  }\n}\n", "const IDENTIFIER_CHECK = /^[$A-Z_][0-9A-Z_$]*$/i;\n\nexport function isValidIdentifier(name: string): boolean {\n  const char = name[0];\n  return (\n    (char === '$' ||\n      char === '_' ||\n      (char >= 'A' && char <= 'Z') ||\n      (char >= 'a' && char <= 'z')) &&\n    IDENTIFIER_CHECK.test(name)\n  );\n}\n", "import { Feature } from '../compat';\nimport {\n  CONSTANT_STRING,\n  ERROR_CONSTRUCTOR_STRING,\n  NIL,\n  SYMBOL_STRING,\n  SerovalNodeType,\n  SerovalObjectFlags,\n} from '../constants';\nimport {\n  SerovalMissingPluginError,\n  SerovalSerializationError,\n  SerovalUnsupportedNodeError,\n} from '../errors';\nimport { createEffectfulFunction, createFunction } from '../function-string';\nimport { REFERENCES_KEY } from '../keys';\nimport type { Plugin, PluginAccessOptions, SerovalMode } from '../plugin';\nimport { serializeSpecialReferenceValue } from '../special-reference';\nimport type {\n  SerovalAggregateErrorNode,\n  SerovalArrayBufferNode,\n  SerovalArrayNode,\n  SerovalAsyncIteratorFactoryInstanceNode,\n  SerovalAsyncIteratorFactoryNode,\n  SerovalBigIntTypedArrayNode,\n  SerovalBoxedNode,\n  SerovalDataViewNode,\n  SerovalDateNode,\n  SerovalErrorNode,\n  SerovalIndexedValueNode,\n  SerovalIteratorFactoryInstanceNode,\n  SerovalIteratorFactoryNode,\n  SerovalMapNode,\n  SerovalNode,\n  SerovalNodeWithID,\n  SerovalNullConstructorNode,\n  SerovalObjectNode,\n  SerovalObjectRecordKey,\n  SerovalObjectRecordNode,\n  SerovalPluginNode,\n  SerovalPromiseConstructorNode,\n  SerovalPromiseNode,\n  SerovalPromiseRejectNode,\n  SerovalPromiseResolveNode,\n  SerovalReferenceNode,\n  SerovalRegExpNode,\n  SerovalSetNode,\n  SerovalSpecialReferenceNode,\n  SerovalStreamConstructorNode,\n  SerovalStreamNextNode,\n  SerovalStreamReturnNode,\n  SerovalStreamThrowNode,\n  SerovalTypedArrayNode,\n  SerovalWKSymbolNode,\n} from '../types';\nimport { isValidIdentifier } from '../utils/is-valid-identifier';\n\nconst enum AssignmentType {\n  Index = 0,\n  Add = 1,\n  Set = 2,\n  Delete = 3,\n}\n\ninterface IndexAssignment {\n  t: AssignmentType.Index;\n  s: string;\n  k: undefined;\n  v: string;\n}\n\ninterface SetAssignment {\n  t: AssignmentType.Set;\n  s: string;\n  k: string;\n  v: string;\n}\n\ninterface AddAssignment {\n  t: AssignmentType.Add;\n  s: string;\n  k: undefined;\n  v: string;\n}\n\ninterface DeleteAssignment {\n  t: AssignmentType.Delete;\n  s: string;\n  k: string;\n  v: undefined;\n}\n\n// Array of assignments to be done (used for recursion)\ntype Assignment =\n  | IndexAssignment\n  | AddAssignment\n  | SetAssignment\n  | DeleteAssignment;\n\nexport interface FlaggedObject {\n  type: SerovalObjectFlags;\n  value: string;\n}\n\nfunction getAssignmentExpression(assignment: Assignment): string {\n  switch (assignment.t) {\n    case AssignmentType.Index:\n      return assignment.s + '=' + assignment.v;\n    case AssignmentType.Set:\n      return assignment.s + '.set(' + assignment.k + ',' + assignment.v + ')';\n    case AssignmentType.Add:\n      return assignment.s + '.add(' + assignment.v + ')';\n    case AssignmentType.Delete:\n      return assignment.s + '.delete(' + assignment.k + ')';\n  }\n}\n\nfunction mergeAssignments(assignments: Assignment[]): Assignment[] {\n  const newAssignments: Assignment[] = [];\n  let current = assignments[0];\n  for (\n    let i = 1, len = assignments.length, item: Assignment, prev = current;\n    i < len;\n    i++\n  ) {\n    item = assignments[i];\n    if (item.t === AssignmentType.Index && item.v === prev.v) {\n      // Merge if the right-hand value is the same\n      // saves at least 2 chars\n      current = {\n        t: AssignmentType.Index,\n        s: item.s,\n        k: NIL,\n        v: getAssignmentExpression(current),\n      } as IndexAssignment;\n    } else if (item.t === AssignmentType.Set && item.s === prev.s) {\n      // Maps has chaining methods, merge if source is the same\n      current = {\n        t: AssignmentType.Set,\n        s: getAssignmentExpression(current),\n        k: item.k,\n        v: item.v,\n      } as SetAssignment;\n    } else if (item.t === AssignmentType.Add && item.s === prev.s) {\n      // Sets has chaining methods too\n      current = {\n        t: AssignmentType.Add,\n        s: getAssignmentExpression(current),\n        k: NIL,\n        v: item.v,\n      } as AddAssignment;\n    } else if (item.t === AssignmentType.Delete && item.s === prev.s) {\n      // Maps has chaining methods, merge if source is the same\n      current = {\n        t: AssignmentType.Delete,\n        s: getAssignmentExpression(current),\n        k: item.k,\n        v: NIL,\n      } as DeleteAssignment;\n    } else {\n      // Different assignment, push current\n      newAssignments.push(current);\n      current = item;\n    }\n    prev = item;\n  }\n\n  newAssignments.push(current);\n\n  return newAssignments;\n}\n\nfunction resolveAssignments(assignments: Assignment[]): string | undefined {\n  if (assignments.length) {\n    let result = '';\n    const merged = mergeAssignments(assignments);\n    for (let i = 0, len = merged.length; i < len; i++) {\n      result += getAssignmentExpression(merged[i]) + ',';\n    }\n    return result;\n  }\n  return NIL;\n}\n\nconst NULL_CONSTRUCTOR = 'Object.create(null)';\nconst SET_CONSTRUCTOR = 'new Set';\nconst MAP_CONSTRUCTOR = 'new Map';\n\nconst PROMISE_RESOLVE = 'Promise.resolve';\nconst PROMISE_REJECT = 'Promise.reject';\n\nconst OBJECT_FLAG_CONSTRUCTOR: Record<SerovalObjectFlags, string | undefined> =\n  {\n    [SerovalObjectFlags.Frozen]: 'Object.freeze',\n    [SerovalObjectFlags.Sealed]: 'Object.seal',\n    [SerovalObjectFlags.NonExtensible]: 'Object.preventExtensions',\n    [SerovalObjectFlags.None]: NIL,\n  };\n\ntype SerovalNodeWithProperties =\n  | SerovalObjectNode\n  | SerovalNullConstructorNode\n  | SerovalAggregateErrorNode\n  | SerovalErrorNode;\n\nexport interface BaseSerializerContextOptions extends PluginAccessOptions {\n  features: number;\n  markedRefs: number[] | Set<number>;\n}\n\nexport default abstract class BaseSerializerContext\n  implements PluginAccessOptions\n{\n  /**\n   * @private\n   */\n  features: number;\n\n  /**\n   * To check if an object is synchronously referencing itself\n   * @private\n   */\n  stack: number[] = [];\n\n  /**\n   * Array of object mutations\n   * @private\n   */\n  flags: FlaggedObject[] = [];\n\n  /**\n   * Array of assignments to be done (used for recursion)\n   * @private\n   */\n  assignments: Assignment[] = [];\n\n  plugins?: Plugin<any, any>[] | undefined;\n\n  /**\n   * Refs that are...referenced\n   * @private\n   */\n  marked: Set<number>;\n\n  constructor(options: BaseSerializerContextOptions) {\n    this.plugins = options.plugins;\n    this.features = options.features;\n    this.marked = new Set(options.markedRefs);\n  }\n\n  abstract readonly mode: SerovalMode;\n\n  createFunction(parameters: string[], body: string): string {\n    return createFunction(this.features, parameters, body);\n  }\n\n  createEffectfulFunction(parameters: string[], body: string): string {\n    return createEffectfulFunction(this.features, parameters, body);\n  }\n\n  /**\n   * A tiny function that tells if a reference\n   * is to be accessed. This is a requirement for\n   * deciding whether or not we should generate\n   * an identifier for the object\n   */\n  protected markRef(id: number): void {\n    this.marked.add(id);\n  }\n\n  protected isMarked(id: number): boolean {\n    return this.marked.has(id);\n  }\n\n  /**\n   * Converts the ID of a reference into a identifier string\n   * that is used to refer to the object instance in the\n   * generated script.\n   */\n  abstract getRefParam(id: number): string;\n\n  protected pushObjectFlag(flag: SerovalObjectFlags, id: number): void {\n    if (flag !== SerovalObjectFlags.None) {\n      this.markRef(id);\n      this.flags.push({\n        type: flag,\n        value: this.getRefParam(id),\n      });\n    }\n  }\n\n  private resolveFlags(): string | undefined {\n    let result = '';\n    for (let i = 0, current = this.flags, len = current.length; i < len; i++) {\n      const flag = current[i];\n      result += OBJECT_FLAG_CONSTRUCTOR[flag.type] + '(' + flag.value + '),';\n    }\n    return result;\n  }\n\n  protected resolvePatches(): string | undefined {\n    const assignments = resolveAssignments(this.assignments);\n    const flags = this.resolveFlags();\n    if (assignments) {\n      if (flags) {\n        return assignments + flags;\n      }\n      return assignments;\n    }\n    return flags;\n  }\n\n  /**\n   * Generates the inlined assignment for the reference\n   * This is different from the assignments array as this one\n   * signifies creation rather than mutation\n   */\n  protected createAssignment(source: string, value: string): void {\n    this.assignments.push({\n      t: AssignmentType.Index,\n      s: source,\n      k: NIL,\n      v: value,\n    });\n  }\n\n  protected createAddAssignment(ref: number, value: string): void {\n    this.assignments.push({\n      t: AssignmentType.Add,\n      s: this.getRefParam(ref),\n      k: NIL,\n      v: value,\n    });\n  }\n\n  protected createSetAssignment(ref: number, key: string, value: string): void {\n    this.assignments.push({\n      t: AssignmentType.Set,\n      s: this.getRefParam(ref),\n      k: key,\n      v: value,\n    });\n  }\n\n  protected createDeleteAssignment(ref: number, key: string): void {\n    this.assignments.push({\n      t: AssignmentType.Delete,\n      s: this.getRefParam(ref),\n      k: key,\n      v: NIL,\n    });\n  }\n\n  protected createArrayAssign(\n    ref: number,\n    index: number | string,\n    value: string,\n  ): void {\n    this.createAssignment(this.getRefParam(ref) + '[' + index + ']', value);\n  }\n\n  protected createObjectAssign(ref: number, key: string, value: string): void {\n    this.createAssignment(this.getRefParam(ref) + '.' + key, value);\n  }\n\n  /**\n   * Checks if the value is in the stack. Stack here is a reference\n   * structure to know if a object is to be accessed in a TDZ.\n   */\n  isIndexedValueInStack(node: SerovalNode): boolean {\n    return (\n      node.t === SerovalNodeType.IndexedValue && this.stack.includes(node.i)\n    );\n  }\n\n  /**\n   * Produces an assignment expression. `id` generates a reference\n   * parameter (through `getRefParam`) and has the option to\n   * return the reference parameter directly or assign a value to\n   * it.\n   */\n  protected abstract assignIndexedValue(id: number, value: string): string;\n\n  protected serializeReference(node: SerovalReferenceNode): string {\n    return this.assignIndexedValue(\n      node.i,\n      REFERENCES_KEY + '.get(\"' + node.s + '\")',\n    );\n  }\n\n  protected serializeArrayItem(\n    id: number,\n    item: SerovalNode | undefined,\n    index: number,\n  ): string {\n    // Check if index is a hole\n    if (item) {\n      // Check if item is a parent\n      if (this.isIndexedValueInStack(item)) {\n        this.markRef(id);\n        this.createArrayAssign(\n          id,\n          index,\n          this.getRefParam((item as SerovalIndexedValueNode).i),\n        );\n        return '';\n      }\n      return this.serialize(item);\n    }\n    return '';\n  }\n\n  protected serializeArray(node: SerovalArrayNode): string {\n    const id = node.i;\n    if (node.l) {\n      this.stack.push(id);\n      const list = node.a;\n      let values = this.serializeArrayItem(id, list[0], 0);\n      // This is different than Map and Set\n      // because we also need to serialize\n      // the holes of the Array\n      let isHoley = values === '';\n      for (let i = 1, len = node.l, item: string; i < len; i++) {\n        item = this.serializeArrayItem(id, list[i], i);\n        values += ',' + item;\n        isHoley = item === '';\n      }\n      this.stack.pop();\n      this.pushObjectFlag(node.o, node.i);\n      return this.assignIndexedValue(id, '[' + values + (isHoley ? ',]' : ']'));\n    }\n    return this.assignIndexedValue(id, '[]');\n  }\n\n  protected serializeProperty(\n    source: SerovalNodeWithProperties,\n    key: SerovalObjectRecordKey,\n    val: SerovalNode,\n  ): string {\n    if (typeof key === 'string') {\n      const check = Number(key);\n      const isIdentifier =\n        // Test if key is a valid positive number or JS identifier\n        // so that we don't have to serialize the key and wrap with brackets\n        (check >= 0 &&\n          // It's also important to consider that if the key is\n          // indeed numeric, we need to make sure that when\n          // converted back into a string, it's still the same\n          // to the original key. This allows us to differentiate\n          // keys that has numeric formats but in a different\n          // format, which can cause unintentional key declaration\n          // Example: { 0x1: 1 } vs { '0x1': 1 }\n          check.toString() === key) ||\n        isValidIdentifier(key);\n      if (this.isIndexedValueInStack(val)) {\n        const refParam = this.getRefParam((val as SerovalIndexedValueNode).i);\n        this.markRef(source.i);\n        // Strict identifier check, make sure\n        // that it isn't numeric (except NaN)\n        if (isIdentifier && check !== check) {\n          this.createObjectAssign(source.i, key, refParam);\n        } else {\n          this.createArrayAssign(\n            source.i,\n            isIdentifier ? key : '\"' + key + '\"',\n            refParam,\n          );\n        }\n        return '';\n      }\n      return (isIdentifier ? key : '\"' + key + '\"') + ':' + this.serialize(val);\n    }\n    return '[' + this.serialize(key) + ']:' + this.serialize(val);\n  }\n\n  protected serializeProperties(\n    source: SerovalNodeWithProperties,\n    record: SerovalObjectRecordNode,\n  ): string {\n    const len = record.s;\n    if (len) {\n      const keys = record.k;\n      const values = record.v;\n      this.stack.push(source.i);\n      let result = this.serializeProperty(source, keys[0], values[0]);\n      for (let i = 1, item = result; i < len; i++) {\n        item = this.serializeProperty(source, keys[i], values[i]);\n        result += (item && result && ',') + item;\n      }\n      this.stack.pop();\n      return '{' + result + '}';\n    }\n    return '{}';\n  }\n\n  protected serializeObject(node: SerovalObjectNode): string {\n    this.pushObjectFlag(node.o, node.i);\n    return this.assignIndexedValue(\n      node.i,\n      this.serializeProperties(node, node.p),\n    );\n  }\n\n  protected serializeWithObjectAssign(\n    source: SerovalNodeWithProperties,\n    value: SerovalObjectRecordNode,\n    serialized: string,\n  ): string {\n    const fields = this.serializeProperties(source, value);\n    if (fields !== '{}') {\n      return 'Object.assign(' + serialized + ',' + fields + ')';\n    }\n    return serialized;\n  }\n\n  private serializeStringKeyAssignment(\n    source: SerovalNodeWithProperties,\n    mainAssignments: Assignment[],\n    key: string,\n    value: SerovalNode,\n  ): void {\n    const serialized = this.serialize(value);\n    const check = Number(key);\n    const isIdentifier =\n      // Test if key is a valid positive number or JS identifier\n      // so that we don't have to serialize the key and wrap with brackets\n      (check >= 0 &&\n        // It's also important to consider that if the key is\n        // indeed numeric, we need to make sure that when\n        // converted back into a string, it's still the same\n        // to the original key. This allows us to differentiate\n        // keys that has numeric formats but in a different\n        // format, which can cause unintentional key declaration\n        // Example: { 0x1: 1 } vs { '0x1': 1 }\n        check.toString() === key) ||\n      isValidIdentifier(key);\n    if (this.isIndexedValueInStack(value)) {\n      // Strict identifier check, make sure\n      // that it isn't numeric (except NaN)\n      if (isIdentifier && check !== check) {\n        this.createObjectAssign(source.i, key, serialized);\n      } else {\n        this.createArrayAssign(\n          source.i,\n          isIdentifier ? key : '\"' + key + '\"',\n          serialized,\n        );\n      }\n    } else {\n      const parentAssignment = this.assignments;\n      this.assignments = mainAssignments;\n      if (isIdentifier && check !== check) {\n        this.createObjectAssign(source.i, key, serialized);\n      } else {\n        this.createArrayAssign(\n          source.i,\n          isIdentifier ? key : '\"' + key + '\"',\n          serialized,\n        );\n      }\n      this.assignments = parentAssignment;\n    }\n  }\n\n  protected serializeAssignment(\n    source: SerovalNodeWithProperties,\n    mainAssignments: Assignment[],\n    key: SerovalObjectRecordKey,\n    value: SerovalNode,\n  ): void {\n    if (typeof key === 'string') {\n      this.serializeStringKeyAssignment(source, mainAssignments, key, value);\n    } else {\n      const parent = this.stack;\n      this.stack = [];\n      const serialized = this.serialize(value);\n      this.stack = parent;\n      const parentAssignment = this.assignments;\n      this.assignments = mainAssignments;\n      this.createArrayAssign(source.i, this.serialize(key), serialized);\n      this.assignments = parentAssignment;\n    }\n  }\n\n  protected serializeAssignments(\n    source: SerovalNodeWithProperties,\n    node: SerovalObjectRecordNode,\n  ): string | undefined {\n    const len = node.s;\n    if (len) {\n      const mainAssignments: Assignment[] = [];\n      const keys = node.k;\n      const values = node.v;\n      this.stack.push(source.i);\n      for (let i = 0; i < len; i++) {\n        this.serializeAssignment(source, mainAssignments, keys[i], values[i]);\n      }\n      this.stack.pop();\n      return resolveAssignments(mainAssignments);\n    }\n    return NIL;\n  }\n\n  protected serializeDictionary(\n    node: SerovalNodeWithProperties,\n    init: string,\n  ): string {\n    if (node.p) {\n      if (this.features & Feature.ObjectAssign) {\n        init = this.serializeWithObjectAssign(node, node.p, init);\n      } else {\n        this.markRef(node.i);\n        const assignments = this.serializeAssignments(node, node.p);\n        if (assignments) {\n          return (\n            '(' +\n            this.assignIndexedValue(node.i, init) +\n            ',' +\n            assignments +\n            this.getRefParam(node.i) +\n            ')'\n          );\n        }\n      }\n    }\n    return this.assignIndexedValue(node.i, init);\n  }\n\n  protected serializeNullConstructor(node: SerovalNullConstructorNode): string {\n    this.pushObjectFlag(node.o, node.i);\n    return this.serializeDictionary(node, NULL_CONSTRUCTOR);\n  }\n\n  protected serializeDate(node: SerovalDateNode): string {\n    return this.assignIndexedValue(node.i, 'new Date(\"' + node.s + '\")');\n  }\n\n  protected serializeRegExp(node: SerovalRegExpNode): string {\n    return this.assignIndexedValue(node.i, '/' + node.c + '/' + node.m);\n  }\n\n  protected serializeSetItem(id: number, item: SerovalNode): string {\n    if (this.isIndexedValueInStack(item)) {\n      this.markRef(id);\n      this.createAddAssignment(\n        id,\n        this.getRefParam((item as SerovalIndexedValueNode).i),\n      );\n      return '';\n    }\n    return this.serialize(item);\n  }\n\n  protected serializeSet(node: SerovalSetNode): string {\n    let serialized = SET_CONSTRUCTOR;\n    const size = node.l;\n    const id = node.i;\n    if (size) {\n      const items = node.a;\n      this.stack.push(id);\n      let result = this.serializeSetItem(id, items[0]);\n      for (let i = 1, item = result; i < size; i++) {\n        item = this.serializeSetItem(id, items[i]);\n        result += (item && result && ',') + item;\n      }\n      this.stack.pop();\n      if (result) {\n        serialized += '([' + result + '])';\n      }\n    }\n    return this.assignIndexedValue(id, serialized);\n  }\n\n  protected serializeMapEntry(\n    id: number,\n    key: SerovalNode,\n    val: SerovalNode,\n    sentinel: string,\n  ): string {\n    if (this.isIndexedValueInStack(key)) {\n      // Create reference for the map instance\n      const keyRef = this.getRefParam((key as SerovalIndexedValueNode).i);\n      this.markRef(id);\n      // Check if value is a parent\n      if (this.isIndexedValueInStack(val)) {\n        const valueRef = this.getRefParam((val as SerovalIndexedValueNode).i);\n        // Register an assignment since\n        // both key and value are a parent of this\n        // Map instance\n        this.createSetAssignment(id, keyRef, valueRef);\n        return '';\n      }\n      // Reset the stack\n      // This is required because the serialized\n      // value is no longer part of the expression\n      // tree and has been moved to the deferred\n      // assignment\n      if (\n        val.t !== SerovalNodeType.IndexedValue &&\n        val.i != null &&\n        this.isMarked(val.i)\n      ) {\n        // We use a trick here using sequence (or comma) expressions\n        // basically we serialize the intended object in place WITHOUT\n        // actually returning it, this is by returning a placeholder\n        // value that we will remove sometime after.\n        const serialized =\n          '(' + this.serialize(val) + ',[' + sentinel + ',' + sentinel + '])';\n        this.createSetAssignment(id, keyRef, this.getRefParam(val.i));\n        this.createDeleteAssignment(id, sentinel);\n        return serialized;\n      }\n      const parent = this.stack;\n      this.stack = [];\n      this.createSetAssignment(id, keyRef, this.serialize(val));\n      this.stack = parent;\n      return '';\n    }\n    if (this.isIndexedValueInStack(val)) {\n      // Create ref for the Map instance\n      const valueRef = this.getRefParam((val as SerovalIndexedValueNode).i);\n      this.markRef(id);\n      if (\n        key.t !== SerovalNodeType.IndexedValue &&\n        key.i != null &&\n        this.isMarked(key.i)\n      ) {\n        const serialized =\n          '(' + this.serialize(key) + ',[' + sentinel + ',' + sentinel + '])';\n        this.createSetAssignment(id, this.getRefParam(key.i), valueRef);\n        this.createDeleteAssignment(id, sentinel);\n        return serialized;\n      }\n      // Reset stack for the key serialization\n      const parent = this.stack;\n      this.stack = [];\n      this.createSetAssignment(id, this.serialize(key), valueRef);\n      this.stack = parent;\n      return '';\n    }\n\n    return '[' + this.serialize(key) + ',' + this.serialize(val) + ']';\n  }\n\n  protected serializeMap(node: SerovalMapNode): string {\n    let serialized = MAP_CONSTRUCTOR;\n    const size = node.e.s;\n    const id = node.i;\n    const sentinel = node.f;\n    const sentinelId = this.getRefParam(sentinel.i);\n    if (size) {\n      const keys = node.e.k;\n      const vals = node.e.v;\n      this.stack.push(id);\n      let result = this.serializeMapEntry(id, keys[0], vals[0], sentinelId);\n      for (let i = 1, item = result; i < size; i++) {\n        item = this.serializeMapEntry(id, keys[i], vals[i], sentinelId);\n        result += (item && result && ',') + item;\n      }\n      this.stack.pop();\n      // Check if there are any values\n      // so that the empty Map constructor\n      // can be used instead\n      if (result) {\n        serialized += '([' + result + '])';\n      }\n    }\n    if (sentinel.t === SerovalNodeType.SpecialReference) {\n      this.markRef(sentinel.i);\n      serialized = '(' + this.serialize(sentinel) + ',' + serialized + ')';\n    }\n    return this.assignIndexedValue(id, serialized);\n  }\n\n  protected serializeArrayBuffer(node: SerovalArrayBufferNode): string {\n    let result = 'new Uint8Array(';\n    const buffer = node.s;\n    const len = buffer.length;\n    if (len) {\n      result += '[' + buffer[0];\n      for (let i = 1; i < len; i++) {\n        result += ',' + buffer[i];\n      }\n      result += ']';\n    }\n    return this.assignIndexedValue(node.i, result + ').buffer');\n  }\n\n  protected serializeTypedArray(\n    node: SerovalTypedArrayNode | SerovalBigIntTypedArrayNode,\n  ): string {\n    return this.assignIndexedValue(\n      node.i,\n      'new ' +\n        node.c +\n        '(' +\n        this.serialize(node.f) +\n        ',' +\n        node.b +\n        ',' +\n        node.l +\n        ')',\n    );\n  }\n\n  protected serializeDataView(node: SerovalDataViewNode): string {\n    return this.assignIndexedValue(\n      node.i,\n      'new DataView(' +\n        this.serialize(node.f) +\n        ',' +\n        node.b +\n        ',' +\n        node.l +\n        ')',\n    );\n  }\n\n  protected serializeAggregateError(node: SerovalAggregateErrorNode): string {\n    const id = node.i;\n    // `AggregateError` might've been extended\n    // either through class or custom properties\n    // Make sure to assign extra properties\n    this.stack.push(id);\n    const serialized = this.serializeDictionary(\n      node,\n      'new AggregateError([],\"' + node.m + '\")',\n    );\n    this.stack.pop();\n    return serialized;\n  }\n\n  protected serializeError(node: SerovalErrorNode): string {\n    return this.serializeDictionary(\n      node,\n      'new ' + ERROR_CONSTRUCTOR_STRING[node.s] + '(\"' + node.m + '\")',\n    );\n  }\n\n  protected serializePromise(node: SerovalPromiseNode): string {\n    let serialized: string;\n    // Check if resolved value is a parent expression\n    const fulfilled = node.f;\n    const id = node.i;\n    const promiseConstructor = node.s ? PROMISE_RESOLVE : PROMISE_REJECT;\n    if (this.isIndexedValueInStack(fulfilled)) {\n      // A Promise trick, reference the value\n      // inside the `then` expression so that\n      // the Promise evaluates after the parent\n      // has initialized\n      const ref = this.getRefParam((fulfilled as SerovalIndexedValueNode).i);\n      serialized =\n        promiseConstructor +\n        (node.s\n          ? '().then(' + this.createFunction([], ref) + ')'\n          : '().catch(' +\n            this.createEffectfulFunction([], 'throw ' + ref) +\n            ')');\n    } else {\n      this.stack.push(id);\n      const result = this.serialize(fulfilled);\n      this.stack.pop();\n      // just inline the value/reference here\n      serialized = promiseConstructor + '(' + result + ')';\n    }\n    return this.assignIndexedValue(id, serialized);\n  }\n\n  protected serializeWellKnownSymbol(node: SerovalWKSymbolNode): string {\n    return this.assignIndexedValue(node.i, SYMBOL_STRING[node.s]);\n  }\n\n  protected serializeBoxed(node: SerovalBoxedNode): string {\n    return this.assignIndexedValue(\n      node.i,\n      'Object(' + this.serialize(node.f) + ')',\n    );\n  }\n\n  protected serializePlugin(node: SerovalPluginNode): string {\n    const currentPlugins = this.plugins;\n    if (currentPlugins) {\n      for (let i = 0, len = currentPlugins.length; i < len; i++) {\n        const plugin = currentPlugins[i];\n        if (plugin.tag === node.c) {\n          return this.assignIndexedValue(\n            node.i,\n            plugin.serialize(node.s, this, {\n              id: node.i,\n            }),\n          );\n        }\n      }\n    }\n    throw new SerovalMissingPluginError(node.c);\n  }\n\n  private getConstructor(node: SerovalNodeWithID): string {\n    const current = this.serialize(node);\n    return current === this.getRefParam(node.i) ? current : '(' + current + ')';\n  }\n\n  protected serializePromiseConstructor(\n    node: SerovalPromiseConstructorNode,\n  ): string {\n    const resolver = this.assignIndexedValue(node.s, '{p:0,s:0,f:0}');\n    return this.assignIndexedValue(\n      node.i,\n      this.getConstructor(node.f) + '(' + resolver + ')',\n    );\n  }\n\n  protected serializePromiseResolve(node: SerovalPromiseResolveNode): string {\n    return (\n      this.getConstructor(node.a[0]) +\n      '(' +\n      this.getRefParam(node.i) +\n      ',' +\n      this.serialize(node.a[1]) +\n      ')'\n    );\n  }\n\n  protected serializePromiseReject(node: SerovalPromiseRejectNode): string {\n    return (\n      this.getConstructor(node.a[0]) +\n      '(' +\n      this.getRefParam(node.i) +\n      ',' +\n      this.serialize(node.a[1]) +\n      ')'\n    );\n  }\n\n  protected serializeSpecialReference(\n    node: SerovalSpecialReferenceNode,\n  ): string {\n    return this.assignIndexedValue(\n      node.i,\n      serializeSpecialReferenceValue(this.features, node.s),\n    );\n  }\n\n  protected serializeIteratorFactory(node: SerovalIteratorFactoryNode): string {\n    let result = '';\n    let initialized = false;\n    if (node.f.t !== SerovalNodeType.IndexedValue) {\n      this.markRef(node.f.i);\n      result = '(' + this.serialize(node.f) + ',';\n      initialized = true;\n    }\n    result += this.assignIndexedValue(\n      node.i,\n      this.createFunction(\n        ['s'],\n        this.createFunction(\n          ['i', 'c', 'd', 't'],\n          '(i=0,t={[' +\n            this.getRefParam(node.f.i) +\n            ']:' +\n            this.createFunction([], 't') +\n            ',next:' +\n            this.createEffectfulFunction(\n              [],\n              'if(i>s.d)return{done:!0,value:void 0};if(d=s.v[c=i++],c===s.t)throw d;return{done:c===s.d,value:d}',\n            ) +\n            '})',\n        ),\n      ),\n    );\n    if (initialized) {\n      result += ')';\n    }\n    return result;\n  }\n\n  protected serializeIteratorFactoryInstance(\n    node: SerovalIteratorFactoryInstanceNode,\n  ): string {\n    return (\n      this.getConstructor(node.a[0]) + '(' + this.serialize(node.a[1]) + ')'\n    );\n  }\n\n  protected serializeAsyncIteratorFactory(\n    node: SerovalAsyncIteratorFactoryNode,\n  ): string {\n    const promise = node.a[0];\n    const symbol = node.a[1];\n\n    let result = '';\n\n    if (promise.t !== SerovalNodeType.IndexedValue) {\n      this.markRef(promise.i);\n      result += '(' + this.serialize(promise);\n    }\n    if (symbol.t !== SerovalNodeType.IndexedValue) {\n      this.markRef(symbol.i);\n      result += (result ? ',' : '(') + this.serialize(symbol);\n    }\n    if (result) {\n      result += ',';\n    }\n\n    const iterator = this.assignIndexedValue(\n      node.i,\n      this.createFunction(\n        ['s'],\n        this.createFunction(\n          ['b', 'c', 'p', 'd', 'e', 't', 'f'],\n          /**\n           * b = resolved values\n           * c = b size\n           * p = pending promises\n           * d = index where the resolved value stops\n           * e = if the last value is a throw\n           * t = placeholder variable\n           * f = finalize\n           */\n          '(b=[],c=0,p=[],d=-1,e=!1,f=' +\n            this.createEffectfulFunction(\n              ['i', 'l'],\n              'for(i=0,l=p.length;i<l;i++)p[i].s({done:!0,value:void 0})',\n            ) +\n            ',s.on({next:' +\n            this.createEffectfulFunction(\n              ['v', 't'],\n              'if(t=p.shift())t.s({done:!1,value:v});b.push(v)',\n            ) +\n            ',throw:' +\n            this.createEffectfulFunction(\n              ['v', 't'],\n              'if(t=p.shift())t.f(v);f(),d=b.length,e=!0,b.push(v)',\n            ) +\n            ',return:' +\n            this.createEffectfulFunction(\n              ['v', 't'],\n              'if(t=p.shift())t.s({done:!0,value:v});f(),d=b.length,b.push(v)',\n            ) +\n            '}),t={[' +\n            this.getRefParam(symbol.i) +\n            ']:' +\n            this.createFunction([], 't.p') +\n            ',next:' +\n            this.createEffectfulFunction(\n              ['i', 't', 'v'],\n              'if(d===-1){return((i=c++)>=b.length)?(' +\n                this.getRefParam(promise.i) +\n                '(t={p:0,s:0,f:0}),p.push(t),t.p):{done:!1,value:b[i]}}if(c>d)return{done:!0,value:void 0};if(v=b[i=c++],i!==d)return{done:!1,value:v};if(e)throw v;return{done:!0,value:v}',\n            ) +\n            '})',\n        ),\n      ),\n    );\n\n    if (result) {\n      return result + iterator + ')';\n    }\n\n    return iterator;\n  }\n\n  protected serializeAsyncIteratorFactoryInstance(\n    node: SerovalAsyncIteratorFactoryInstanceNode,\n  ): string {\n    return (\n      this.getConstructor(node.a[0]) + '(' + this.serialize(node.a[1]) + ')'\n    );\n  }\n\n  protected serializeStreamConstructor(\n    node: SerovalStreamConstructorNode,\n  ): string {\n    const result = this.assignIndexedValue(\n      node.i,\n      this.getConstructor(node.f) + '()',\n    );\n    const len = node.a.length;\n    if (len) {\n      let values = this.serialize(node.a[0]);\n      for (let i = 1; i < len; i++) {\n        values += ',' + this.serialize(node.a[i]);\n      }\n      return '(' + result + ',' + values + ',' + this.getRefParam(node.i) + ')';\n    }\n    return result;\n  }\n\n  protected serializeStreamNext(node: SerovalStreamNextNode): string {\n    return this.getRefParam(node.i) + '.next(' + this.serialize(node.f) + ')';\n  }\n\n  protected serializeStreamThrow(node: SerovalStreamThrowNode): string {\n    return this.getRefParam(node.i) + '.throw(' + this.serialize(node.f) + ')';\n  }\n\n  protected serializeStreamReturn(node: SerovalStreamReturnNode): string {\n    return this.getRefParam(node.i) + '.return(' + this.serialize(node.f) + ')';\n  }\n\n  serialize(node: SerovalNode): string {\n    try {\n      switch (node.t) {\n        case SerovalNodeType.Constant:\n          return CONSTANT_STRING[node.s];\n        case SerovalNodeType.Number:\n          return '' + node.s;\n        case SerovalNodeType.String:\n          return '\"' + node.s + '\"';\n        case SerovalNodeType.BigInt:\n          return node.s + 'n';\n        case SerovalNodeType.IndexedValue:\n          return this.getRefParam(node.i);\n        case SerovalNodeType.Reference:\n          return this.serializeReference(node);\n        case SerovalNodeType.Array:\n          return this.serializeArray(node);\n        case SerovalNodeType.Object:\n          return this.serializeObject(node);\n        case SerovalNodeType.NullConstructor:\n          return this.serializeNullConstructor(node);\n        case SerovalNodeType.Date:\n          return this.serializeDate(node);\n        case SerovalNodeType.RegExp:\n          return this.serializeRegExp(node);\n        case SerovalNodeType.Set:\n          return this.serializeSet(node);\n        case SerovalNodeType.Map:\n          return this.serializeMap(node);\n        case SerovalNodeType.ArrayBuffer:\n          return this.serializeArrayBuffer(node);\n        case SerovalNodeType.BigIntTypedArray:\n        case SerovalNodeType.TypedArray:\n          return this.serializeTypedArray(node);\n        case SerovalNodeType.DataView:\n          return this.serializeDataView(node);\n        case SerovalNodeType.AggregateError:\n          return this.serializeAggregateError(node);\n        case SerovalNodeType.Error:\n          return this.serializeError(node);\n        case SerovalNodeType.Promise:\n          return this.serializePromise(node);\n        case SerovalNodeType.WKSymbol:\n          return this.serializeWellKnownSymbol(node);\n        case SerovalNodeType.Boxed:\n          return this.serializeBoxed(node);\n        case SerovalNodeType.PromiseConstructor:\n          return this.serializePromiseConstructor(node);\n        case SerovalNodeType.PromiseSuccess:\n          return this.serializePromiseResolve(node);\n        case SerovalNodeType.PromiseFailure:\n          return this.serializePromiseReject(node);\n        case SerovalNodeType.Plugin:\n          return this.serializePlugin(node);\n        case SerovalNodeType.SpecialReference:\n          return this.serializeSpecialReference(node);\n        case SerovalNodeType.IteratorFactory:\n          return this.serializeIteratorFactory(node);\n        case SerovalNodeType.IteratorFactoryInstance:\n          return this.serializeIteratorFactoryInstance(node);\n        case SerovalNodeType.AsyncIteratorFactory:\n          return this.serializeAsyncIteratorFactory(node);\n        case SerovalNodeType.AsyncIteratorFactoryInstance:\n          return this.serializeAsyncIteratorFactoryInstance(node);\n        case SerovalNodeType.StreamConstructor:\n          return this.serializeStreamConstructor(node);\n        case SerovalNodeType.StreamNext:\n          return this.serializeStreamNext(node);\n        case SerovalNodeType.StreamThrow:\n          return this.serializeStreamThrow(node);\n        case SerovalNodeType.StreamReturn:\n          return this.serializeStreamReturn(node);\n        default:\n          throw new SerovalUnsupportedNodeError(node);\n      }\n    } catch (error) {\n      throw new SerovalSerializationError(error);\n    }\n  }\n}\n", "import { SerovalNodeType } from '../constants';\nimport type { BaseSerializerContextOptions } from '../context/serializer';\nimport BaseSerializerContext from '../context/serializer';\nimport { GLOBAL_CONTEXT_REFERENCES } from '../keys';\nimport type { SerovalMode } from '../plugin';\nimport { serializeString } from '../string';\nimport type { SerovalNode } from '../types';\nimport type { CrossContextOptions } from './parser';\n\nexport interface CrossSerializerContextOptions\n  extends BaseSerializerContextOptions,\n    CrossContextOptions {}\n\nexport default class CrossSerializerContext extends BaseSerializerContext {\n  readonly mode: SerovalMode = 'cross';\n\n  scopeId?: string;\n\n  constructor(options: CrossSerializerContextOptions) {\n    super(options);\n    this.scopeId = options.scopeId;\n  }\n\n  getRefParam(id: number): string {\n    return GLOBAL_CONTEXT_REFERENCES + '[' + id + ']';\n  }\n\n  protected assignIndexedValue(index: number, value: string): string {\n    // In cross-reference, we have to assume that\n    // every reference are going to be referenced\n    // in the future, and so we need to store\n    // all of it into the reference array.\n    return this.getRefParam(index) + '=' + value;\n  }\n\n  serializeTop(tree: SerovalNode): string {\n    // Get the serialized result\n    const result = this.serialize(tree);\n    // If the node is a non-reference, return\n    // the result immediately\n    const id = tree.i;\n    if (id == null) {\n      return result;\n    }\n    // Get the patches\n    const patches = this.resolvePatches();\n    // Get the variable that represents the root\n    const ref = this.getRefParam(id);\n    // Parameters needed for scoping\n    const params = this.scopeId == null ? '' : GLOBAL_CONTEXT_REFERENCES;\n    // If there are patches, append it after the result\n    const body = patches ? '(' + result + ',' + patches + ref + ')' : result;\n    // If there are no params, there's no need to generate a function\n    if (params === '') {\n      if (tree.t === SerovalNodeType.Object && !patches) {\n        return '(' + body + ')';\n      }\n      return body;\n    }\n    // Get the arguments for the IIFE\n    const args =\n      this.scopeId == null\n        ? '()'\n        : '(' +\n          GLOBAL_CONTEXT_REFERENCES +\n          '[\"' +\n          serializeString(this.scopeId) +\n          '\"])';\n    // Create the IIFE\n    return '(' + this.createFunction([params], body) + ')' + args;\n  }\n}\n", "import {\n  createAggregateErrorNode,\n  createArrayBufferNode,\n  createArrayNode,\n  createAsyncIteratorFactoryInstanceNode,\n  createBigIntNode,\n  createBigIntTypedArrayNode,\n  createBoxedNode,\n  createDataViewNode,\n  createDateNode,\n  createErrorNode,\n  createIteratorFactoryInstanceNode,\n  createNumberNode,\n  createPluginNode,\n  createRegExpNode,\n  createSetNode,\n  createStreamConstructorNode,\n  createStringNode,\n  createTypedArrayNode,\n} from '../../base-primitives';\nimport { Feature } from '../../compat';\nimport { NIL } from '../../constants';\nimport { SerovalParserError, SerovalUnsupportedTypeError } from '../../errors';\nimport {\n  FALSE_NODE,\n  NULL_NODE,\n  TRUE_NODE,\n  UNDEFINED_NODE,\n} from '../../literals';\nimport { OpaqueReference } from '../../opaque-reference';\nimport { SpecialReference } from '../../special-reference';\nimport type { Stream } from '../../stream';\nimport { createStream, isStream } from '../../stream';\nimport { serializeString } from '../../string';\nimport type {\n  SerovalAggregateErrorNode,\n  SerovalArrayNode,\n  SerovalBigIntTypedArrayNode,\n  SerovalBoxedNode,\n  SerovalDataViewNode,\n  SerovalErrorNode,\n  SerovalMapNode,\n  SerovalNode,\n  SerovalNullConstructorNode,\n  SerovalObjectNode,\n  SerovalObjectRecordKey,\n  SerovalObjectRecordNode,\n  SerovalPluginNode,\n  SerovalPromiseConstructorNode,\n  SerovalSetNode,\n  SerovalTypedArrayNode,\n} from '../../types';\nimport { getErrorOptions } from '../../utils/error';\nimport { iteratorToSequence } from '../../utils/iterator-to-sequence';\nimport type {\n  BigIntTypedArrayValue,\n  TypedArrayValue,\n} from '../../utils/typed-array';\nimport type { BaseParserContextOptions } from '../parser';\nimport { BaseParserContext, ParserNodeType } from '../parser';\n\ntype ObjectLikeNode = SerovalObjectNode | SerovalNullConstructorNode;\n\nexport type BaseSyncParserContextOptions = BaseParserContextOptions;\n\nexport default abstract class BaseSyncParserContext extends BaseParserContext {\n  protected parseItems(current: unknown[]): SerovalNode[] {\n    const nodes = [];\n    for (let i = 0, len = current.length; i < len; i++) {\n      if (i in current) {\n        nodes[i] = this.parse(current[i]);\n      }\n    }\n    return nodes;\n  }\n\n  protected parseArray(id: number, current: unknown[]): SerovalArrayNode {\n    return createArrayNode(id, current, this.parseItems(current));\n  }\n\n  protected parseProperties(\n    properties: Record<string | symbol, unknown>,\n  ): SerovalObjectRecordNode {\n    const entries = Object.entries(properties);\n    const keyNodes: SerovalObjectRecordKey[] = [];\n    const valueNodes: SerovalNode[] = [];\n    for (let i = 0, len = entries.length; i < len; i++) {\n      keyNodes.push(serializeString(entries[i][0]));\n      valueNodes.push(this.parse(entries[i][1]));\n    }\n    // Check special properties, symbols in this case\n    let symbol = Symbol.iterator;\n    if (symbol in properties) {\n      keyNodes.push(this.parseWellKnownSymbol(symbol));\n      valueNodes.push(\n        createIteratorFactoryInstanceNode(\n          this.parseIteratorFactory(),\n          this.parse(\n            iteratorToSequence(properties as unknown as Iterable<unknown>),\n          ),\n        ),\n      );\n    }\n    symbol = Symbol.asyncIterator;\n    if (symbol in properties) {\n      keyNodes.push(this.parseWellKnownSymbol(symbol));\n      valueNodes.push(\n        createAsyncIteratorFactoryInstanceNode(\n          this.parseAsyncIteratorFactory(),\n          this.parse(createStream()),\n        ),\n      );\n    }\n    symbol = Symbol.toStringTag;\n    if (symbol in properties) {\n      keyNodes.push(this.parseWellKnownSymbol(symbol));\n      valueNodes.push(createStringNode(properties[symbol] as string));\n    }\n    symbol = Symbol.isConcatSpreadable;\n    if (symbol in properties) {\n      keyNodes.push(this.parseWellKnownSymbol(symbol));\n      valueNodes.push(properties[symbol] ? TRUE_NODE : FALSE_NODE);\n    }\n    return {\n      k: keyNodes,\n      v: valueNodes,\n      s: keyNodes.length,\n    };\n  }\n\n  protected parsePlainObject(\n    id: number,\n    current: Record<string, unknown>,\n    empty: boolean,\n  ): ObjectLikeNode {\n    return this.createObjectNode(\n      id,\n      current,\n      empty,\n      this.parseProperties(current),\n    );\n  }\n\n  protected parseBoxed(id: number, current: object): SerovalBoxedNode {\n    return createBoxedNode(id, this.parse(current.valueOf()));\n  }\n\n  protected parseTypedArray(\n    id: number,\n    current: TypedArrayValue,\n  ): SerovalTypedArrayNode {\n    return createTypedArrayNode(id, current, this.parse(current.buffer));\n  }\n\n  protected parseBigIntTypedArray(\n    id: number,\n    current: BigIntTypedArrayValue,\n  ): SerovalBigIntTypedArrayNode {\n    return createBigIntTypedArrayNode(id, current, this.parse(current.buffer));\n  }\n\n  protected parseDataView(id: number, current: DataView): SerovalDataViewNode {\n    return createDataViewNode(id, current, this.parse(current.buffer));\n  }\n\n  protected parseError(id: number, current: Error): SerovalErrorNode {\n    const options = getErrorOptions(current, this.features);\n    return createErrorNode(\n      id,\n      current,\n      options ? this.parseProperties(options) : NIL,\n    );\n  }\n\n  protected parseAggregateError(\n    id: number,\n    current: AggregateError,\n  ): SerovalAggregateErrorNode {\n    const options = getErrorOptions(current, this.features);\n    return createAggregateErrorNode(\n      id,\n      current,\n      options ? this.parseProperties(options) : NIL,\n    );\n  }\n\n  protected parseMap(\n    id: number,\n    current: Map<unknown, unknown>,\n  ): SerovalMapNode {\n    const keyNodes: SerovalNode[] = [];\n    const valueNodes: SerovalNode[] = [];\n    for (const [key, value] of current.entries()) {\n      keyNodes.push(this.parse(key));\n      valueNodes.push(this.parse(value));\n    }\n    return this.createMapNode(id, keyNodes, valueNodes, current.size);\n  }\n\n  protected parseSet(id: number, current: Set<unknown>): SerovalSetNode {\n    const items: SerovalNode[] = [];\n    for (const item of current.keys()) {\n      items.push(this.parse(item));\n    }\n    return createSetNode(id, current.size, items);\n  }\n\n  protected parsePlugin(\n    id: number,\n    current: unknown,\n  ): SerovalPluginNode | undefined {\n    const currentPlugins = this.plugins;\n    if (currentPlugins) {\n      for (let i = 0, len = currentPlugins.length; i < len; i++) {\n        const plugin = currentPlugins[i];\n        if (plugin.parse.sync && plugin.test(current)) {\n          return createPluginNode(\n            id,\n            plugin.tag,\n            plugin.parse.sync(current, this, {\n              id,\n            }),\n          );\n        }\n      }\n    }\n    return undefined;\n  }\n\n  protected parseStream(id: number, _current: Stream<unknown>): SerovalNode {\n    return createStreamConstructorNode(\n      id,\n      this.parseSpecialReference(SpecialReference.StreamConstructor),\n      [],\n    );\n  }\n\n  protected parsePromise(\n    id: number,\n    _current: Promise<unknown>,\n  ): SerovalPromiseConstructorNode {\n    return this.createPromiseConstructorNode(id, this.createIndex({}));\n  }\n\n  // biome-ignore lint/complexity/noExcessiveCognitiveComplexity: ehh\n  protected parseObject(id: number, current: object): SerovalNode {\n    if (Array.isArray(current)) {\n      return this.parseArray(id, current);\n    }\n    if (isStream(current)) {\n      return this.parseStream(id, current);\n    }\n    const currentClass = current.constructor;\n    if (currentClass === OpaqueReference) {\n      return this.parse(\n        (current as OpaqueReference<unknown, unknown>).replacement,\n      );\n    }\n    const parsed = this.parsePlugin(id, current);\n    if (parsed) {\n      return parsed;\n    }\n    switch (currentClass) {\n      case Object:\n        return this.parsePlainObject(\n          id,\n          current as Record<string, unknown>,\n          false,\n        );\n      case undefined:\n        return this.parsePlainObject(\n          id,\n          current as Record<string, unknown>,\n          true,\n        );\n      case Date:\n        return createDateNode(id, current as unknown as Date);\n      case RegExp:\n        return createRegExpNode(id, current as unknown as RegExp);\n      case Error:\n      case EvalError:\n      case RangeError:\n      case ReferenceError:\n      case SyntaxError:\n      case TypeError:\n      case URIError:\n        return this.parseError(id, current as unknown as Error);\n      case Number:\n      case Boolean:\n      case String:\n      case BigInt:\n        return this.parseBoxed(id, current);\n      case ArrayBuffer:\n        return createArrayBufferNode(id, current as unknown as ArrayBuffer);\n      case Int8Array:\n      case Int16Array:\n      case Int32Array:\n      case Uint8Array:\n      case Uint16Array:\n      case Uint32Array:\n      case Uint8ClampedArray:\n      case Float32Array:\n      case Float64Array:\n        return this.parseTypedArray(id, current as unknown as TypedArrayValue);\n      case DataView:\n        return this.parseDataView(id, current as unknown as DataView);\n      case Map:\n        return this.parseMap(id, current as unknown as Map<unknown, unknown>);\n      case Set:\n        return this.parseSet(id, current as unknown as Set<unknown>);\n      default:\n        break;\n    }\n    // Promises\n    if (currentClass === Promise || current instanceof Promise) {\n      return this.parsePromise(id, current as unknown as Promise<unknown>);\n    }\n    const currentFeatures = this.features;\n    // BigInt Typed Arrays\n    if (currentFeatures & Feature.BigIntTypedArray) {\n      switch (currentClass) {\n        case BigInt64Array:\n        case BigUint64Array:\n          return this.parseBigIntTypedArray(\n            id,\n            current as unknown as BigIntTypedArrayValue,\n          );\n        default:\n          break;\n      }\n    }\n    if (\n      currentFeatures & Feature.AggregateError &&\n      typeof AggregateError !== 'undefined' &&\n      (currentClass === AggregateError || current instanceof AggregateError)\n    ) {\n      return this.parseAggregateError(id, current as unknown as AggregateError);\n    }\n    // Slow path. We only need to handle Errors and Iterators\n    // since they have very broad implementations.\n    if (current instanceof Error) {\n      return this.parseError(id, current);\n    }\n    // Generator functions don't have a global constructor\n    // despite existing\n    if (Symbol.iterator in current || Symbol.asyncIterator in current) {\n      return this.parsePlainObject(id, current, !!currentClass);\n    }\n    throw new SerovalUnsupportedTypeError(current);\n  }\n\n  protected parseFunction(current: unknown): SerovalNode {\n    const ref = this.getReference(current);\n    if (ref.type !== ParserNodeType.Fresh) {\n      return ref.value;\n    }\n    const plugin = this.parsePlugin(ref.value, current);\n    if (plugin) {\n      return plugin;\n    }\n    throw new SerovalUnsupportedTypeError(current);\n  }\n\n  parse<T>(current: T): SerovalNode {\n    switch (typeof current) {\n      case 'boolean':\n        return current ? TRUE_NODE : FALSE_NODE;\n      case 'undefined':\n        return UNDEFINED_NODE;\n      case 'string':\n        return createStringNode(current as string);\n      case 'number':\n        return createNumberNode(current as number);\n      case 'bigint':\n        return createBigIntNode(current as bigint);\n      case 'object': {\n        if (current) {\n          const ref = this.getReference(current);\n          return ref.type === ParserNodeType.Fresh\n            ? this.parseObject(ref.value, current as object)\n            : ref.value;\n        }\n        return NULL_NODE;\n      }\n      case 'symbol':\n        return this.parseWellKnownSymbol(current);\n      case 'function': {\n        return this.parseFunction(current);\n      }\n      default:\n        throw new SerovalUnsupportedTypeError(current);\n    }\n  }\n\n  parseTop<T>(current: T): SerovalNode {\n    try {\n      return this.parse(current);\n    } catch (error) {\n      throw error instanceof SerovalParserError\n        ? error\n        : new SerovalParserError(error);\n    }\n  }\n}\n", "import {\n  createAsyncIteratorFactoryInstanceNode,\n  createIteratorFactoryInstanceNode,\n  createPluginNode,\n  createStreamConstructorNode,\n  createStreamNextNode,\n  createStreamReturnNode,\n  createStreamThrowNode,\n  createStringNode,\n} from '../../base-primitives';\nimport { NIL, SerovalNodeType } from '../../constants';\nimport { FALSE_NODE, TRUE_NODE } from '../../literals';\nimport { createSerovalNode } from '../../node';\nimport { SpecialReference } from '../../special-reference';\nimport type { Stream } from '../../stream';\nimport { createStreamFromAsyncIterable } from '../../stream';\nimport { serializeString } from '../../string';\nimport type {\n  SerovalNode,\n  SerovalObjectRecordKey,\n  SerovalObjectRecordNode,\n  SerovalPluginNode,\n  SerovalPromiseConstructorNode,\n} from '../../types';\nimport { iteratorToSequence } from '../../utils/iterator-to-sequence';\nimport type { BaseSyncParserContextOptions } from './sync';\nimport BaseSyncParserContext from './sync';\n\nexport interface BaseStreamParserContextOptions\n  extends BaseSyncParserContextOptions {\n  onParse: (node: SerovalNode, initial: boolean) => void;\n  onError?: (error: unknown) => void;\n  onDone?: () => void;\n}\n\nexport default abstract class BaseStreamParserContext extends BaseSyncParserContext {\n  // Life\n  private alive = true;\n\n  // Amount of pending promises/streams\n  private pending = 0;\n\n  private onParseCallback: (node: SerovalNode, initial: boolean) => void;\n\n  private onErrorCallback?: (error: unknown) => void;\n\n  private onDoneCallback?: () => void;\n\n  constructor(options: BaseStreamParserContextOptions) {\n    super(options);\n    this.onParseCallback = options.onParse;\n    this.onErrorCallback = options.onError;\n    this.onDoneCallback = options.onDone;\n  }\n\n  private initial = true;\n\n  private buffer: SerovalNode[] = [];\n\n  private onParseInternal(node: SerovalNode, initial: boolean): void {\n    try {\n      this.onParseCallback(node, initial);\n    } catch (error) {\n      this.onError(error);\n    }\n  }\n\n  private flush(): void {\n    for (let i = 0, len = this.buffer.length; i < len; i++) {\n      this.onParseInternal(this.buffer[i], false);\n    }\n  }\n\n  onParse(node: SerovalNode): void {\n    if (this.initial) {\n      this.buffer.push(node);\n    } else {\n      this.onParseInternal(node, false);\n    }\n  }\n\n  onError(error: unknown): void {\n    if (this.onErrorCallback) {\n      this.onErrorCallback(error);\n    } else {\n      throw error;\n    }\n  }\n\n  private onDone(): void {\n    if (this.onDoneCallback) {\n      this.onDoneCallback();\n    }\n  }\n\n  pushPendingState(): void {\n    this.pending++;\n  }\n\n  popPendingState(): void {\n    if (--this.pending <= 0) {\n      this.onDone();\n    }\n  }\n\n  protected parseProperties(\n    properties: Record<string | symbol, unknown>,\n  ): SerovalObjectRecordNode {\n    const entries = Object.entries(properties);\n    const keyNodes: SerovalObjectRecordKey[] = [];\n    const valueNodes: SerovalNode[] = [];\n    for (let i = 0, len = entries.length; i < len; i++) {\n      keyNodes.push(serializeString(entries[i][0]));\n      valueNodes.push(this.parse(entries[i][1]));\n    }\n    // Check special properties, symbols in this case\n    let symbol = Symbol.iterator;\n    if (symbol in properties) {\n      keyNodes.push(this.parseWellKnownSymbol(symbol));\n      valueNodes.push(\n        createIteratorFactoryInstanceNode(\n          this.parseIteratorFactory(),\n          this.parse(\n            iteratorToSequence(properties as unknown as Iterable<unknown>),\n          ),\n        ),\n      );\n    }\n    symbol = Symbol.asyncIterator;\n    if (symbol in properties) {\n      keyNodes.push(this.parseWellKnownSymbol(symbol));\n      valueNodes.push(\n        createAsyncIteratorFactoryInstanceNode(\n          this.parseAsyncIteratorFactory(),\n          this.parse(\n            createStreamFromAsyncIterable(\n              properties as unknown as AsyncIterable<unknown>,\n            ),\n          ),\n        ),\n      );\n    }\n    symbol = Symbol.toStringTag;\n    if (symbol in properties) {\n      keyNodes.push(this.parseWellKnownSymbol(symbol));\n      valueNodes.push(createStringNode(properties[symbol] as string));\n    }\n    symbol = Symbol.isConcatSpreadable;\n    if (symbol in properties) {\n      keyNodes.push(this.parseWellKnownSymbol(symbol));\n      valueNodes.push(properties[symbol] ? TRUE_NODE : FALSE_NODE);\n    }\n    return {\n      k: keyNodes,\n      v: valueNodes,\n      s: keyNodes.length,\n    };\n  }\n\n  protected handlePromiseSuccess(id: number, data: unknown): void {\n    const parsed = this.parseWithError(data);\n    if (parsed) {\n      this.onParse(\n        createSerovalNode(\n          SerovalNodeType.PromiseSuccess,\n          id,\n          NIL,\n          NIL,\n          NIL,\n          NIL,\n          NIL,\n          NIL,\n          [this.parseSpecialReference(SpecialReference.PromiseSuccess), parsed],\n          NIL,\n          NIL,\n          NIL,\n        ),\n      );\n    }\n    this.popPendingState();\n  }\n\n  protected handlePromiseFailure(id: number, data: unknown): void {\n    if (this.alive) {\n      const parsed = this.parseWithError(data);\n      if (parsed) {\n        this.onParse(\n          createSerovalNode(\n            SerovalNodeType.PromiseFailure,\n            id,\n            NIL,\n            NIL,\n            NIL,\n            NIL,\n            NIL,\n            NIL,\n            [\n              this.parseSpecialReference(SpecialReference.PromiseFailure),\n              parsed,\n            ],\n            NIL,\n            NIL,\n            NIL,\n          ),\n        );\n      }\n    }\n    this.popPendingState();\n  }\n\n  protected parsePromise(\n    id: number,\n    current: Promise<unknown>,\n  ): SerovalPromiseConstructorNode {\n    const resolver = this.createIndex({});\n    current.then(\n      this.handlePromiseSuccess.bind(this, resolver),\n      this.handlePromiseFailure.bind(this, resolver),\n    );\n    this.pushPendingState();\n    return this.createPromiseConstructorNode(id, resolver);\n  }\n\n  protected parsePlugin(\n    id: number,\n    current: unknown,\n  ): SerovalPluginNode | undefined {\n    const currentPlugins = this.plugins;\n    if (currentPlugins) {\n      for (let i = 0, len = currentPlugins.length; i < len; i++) {\n        const plugin = currentPlugins[i];\n        if (plugin.parse.stream && plugin.test(current)) {\n          return createPluginNode(\n            id,\n            plugin.tag,\n            plugin.parse.stream(current, this, {\n              id,\n            }),\n          );\n        }\n      }\n    }\n    return NIL;\n  }\n\n  protected parseStream(id: number, current: Stream<unknown>): SerovalNode {\n    const result = createStreamConstructorNode(\n      id,\n      this.parseSpecialReference(SpecialReference.StreamConstructor),\n      [],\n    );\n    this.pushPendingState();\n    current.on({\n      next: value => {\n        if (this.alive) {\n          const parsed = this.parseWithError(value);\n          if (parsed) {\n            this.onParse(createStreamNextNode(id, parsed));\n          }\n        }\n      },\n      throw: value => {\n        if (this.alive) {\n          const parsed = this.parseWithError(value);\n          if (parsed) {\n            this.onParse(createStreamThrowNode(id, parsed));\n          }\n        }\n        this.popPendingState();\n      },\n      return: value => {\n        if (this.alive) {\n          const parsed = this.parseWithError(value);\n          if (parsed) {\n            this.onParse(createStreamReturnNode(id, parsed));\n          }\n        }\n        this.popPendingState();\n      },\n    });\n    return result;\n  }\n\n  parseWithError<T>(current: T): SerovalNode | undefined {\n    try {\n      return this.parse(current);\n    } catch (err) {\n      this.onError(err);\n      return NIL;\n    }\n  }\n\n  /**\n   * @private\n   */\n  start<T>(current: T): void {\n    const parsed = this.parseWithError(current);\n    if (parsed) {\n      this.onParseInternal(parsed, true);\n      this.initial = false;\n      this.flush();\n\n      // Check if there's any pending pushes\n      if (this.pending <= 0) {\n        this.destroy();\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  destroy(): void {\n    if (this.alive) {\n      this.onDone();\n      this.alive = false;\n    }\n  }\n\n  isAlive(): boolean {\n    return this.alive;\n  }\n}\n", "import type { BaseStreamParserContextOptions } from '../context/parser/stream';\nimport BaseStreamParserContext from '../context/parser/stream';\nimport type { SerovalMode } from '../plugin';\n\nexport type CrossStreamParserContextOptions = BaseStreamParserContextOptions;\n\nexport default class CrossStreamParserContext extends BaseStreamParserContext {\n  readonly mode: SerovalMode = 'cross';\n}\n", "import BaseSyncParserContext from '../context/parser/sync';\nimport type { SerovalMode } from '../plugin';\nimport type { CrossParserContextOptions } from './parser';\n\nexport type CrossSyncParserContextOptions = CrossParserContextOptions;\n\nexport default class CrossSyncParserContext extends BaseSyncParserContext {\n  readonly mode: SerovalMode = 'cross';\n}\n", "import { resolvePlugins } from '../plugin';\nimport type { SerovalNode } from '../types';\nimport type { CrossAsyncParserContextOptions } from './async';\nimport AsyncCrossParserContext from './async';\nimport type { CrossDeserializerContextOptions } from './deserializer';\nimport CrossDeserializerContext from './deserializer';\nimport type { CrossContextOptions, CrossParserContextOptions } from './parser';\nimport CrossSerializerContext from './serializer';\nimport type { CrossStreamParserContextOptions } from './stream';\nimport StreamCrossParserContext from './stream';\nimport type { CrossSyncParserContextOptions } from './sync';\nimport SyncCrossParserContext from './sync';\n\nexport interface CrossSerializeOptions\n  extends CrossSyncParserContextOptions,\n    CrossContextOptions {}\n\nexport function crossSerialize<T>(\n  source: T,\n  options: CrossSerializeOptions = {},\n): string {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = new SyncCrossParserContext({\n    plugins,\n    disabledFeatures: options.disabledFeatures,\n    refs: options.refs,\n  });\n  const tree = ctx.parseTop(source);\n  const serial = new CrossSerializerContext({\n    plugins,\n    features: ctx.features,\n    scopeId: options.scopeId,\n    markedRefs: ctx.marked,\n  });\n  return serial.serializeTop(tree);\n}\n\nexport interface CrossSerializeAsyncOptions\n  extends CrossAsyncParserContextOptions,\n    CrossContextOptions {}\n\nexport async function crossSerializeAsync<T>(\n  source: T,\n  options: CrossSerializeAsyncOptions = {},\n): Promise<string> {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = new AsyncCrossParserContext({\n    plugins,\n    disabledFeatures: options.disabledFeatures,\n    refs: options.refs,\n  });\n  const tree = await ctx.parseTop(source);\n  const serial = new CrossSerializerContext({\n    plugins,\n    features: ctx.features,\n    scopeId: options.scopeId,\n    markedRefs: ctx.marked,\n  });\n  return serial.serializeTop(tree);\n}\n\nexport type ToCrossJSONOptions = CrossParserContextOptions;\n\nexport function toCrossJSON<T>(\n  source: T,\n  options: CrossParserContextOptions = {},\n): SerovalNode {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = new SyncCrossParserContext({\n    plugins,\n    disabledFeatures: options.disabledFeatures,\n    refs: options.refs,\n  });\n  return ctx.parseTop(source);\n}\n\nexport type ToCrossJSONAsyncOptions = CrossParserContextOptions;\n\nexport async function toCrossJSONAsync<T>(\n  source: T,\n  options: CrossParserContextOptions = {},\n): Promise<SerovalNode> {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = new AsyncCrossParserContext({\n    plugins,\n    disabledFeatures: options.disabledFeatures,\n    refs: options.refs,\n  });\n  return await ctx.parseTop(source);\n}\n\nexport interface CrossSerializeStreamOptions\n  extends Omit<CrossStreamParserContextOptions, 'onParse'>,\n    CrossContextOptions {\n  onSerialize: (data: string, initial: boolean) => void;\n}\n\nexport function crossSerializeStream<T>(\n  source: T,\n  options: CrossSerializeStreamOptions,\n): () => void {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = new StreamCrossParserContext({\n    plugins,\n    refs: options.refs,\n    disabledFeatures: options.disabledFeatures,\n    onParse(node, initial): void {\n      const serial = new CrossSerializerContext({\n        plugins,\n        features: ctx.features,\n        scopeId: options.scopeId,\n        markedRefs: ctx.marked,\n      });\n\n      let serialized: string;\n\n      try {\n        serialized = serial.serializeTop(node);\n      } catch (err) {\n        if (options.onError) {\n          options.onError(err);\n        }\n        return;\n      }\n\n      options.onSerialize(serialized, initial);\n    },\n    onError: options.onError,\n    onDone: options.onDone,\n  });\n\n  ctx.start(source);\n\n  return ctx.destroy.bind(ctx);\n}\n\nexport type ToCrossJSONStreamOptions = CrossStreamParserContextOptions;\n\nexport function toCrossJSONStream<T>(\n  source: T,\n  options: ToCrossJSONStreamOptions,\n): () => void {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = new StreamCrossParserContext({\n    plugins,\n    refs: options.refs,\n    disabledFeatures: options.disabledFeatures,\n    onParse: options.onParse,\n    onError: options.onError,\n    onDone: options.onDone,\n  });\n\n  ctx.start(source);\n\n  return ctx.destroy.bind(ctx);\n}\n\nexport type FromCrossJSONOptions = CrossDeserializerContextOptions;\n\nexport function fromCrossJSON<T>(\n  source: SerovalNode,\n  options: FromCrossJSONOptions,\n): T {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = new CrossDeserializerContext({\n    plugins,\n    refs: options.refs,\n  });\n  return ctx.deserializeTop(source) as T;\n}\n", "import type { BaseParserContextOptions } from '../context/parser';\nimport BaseAsyncParserContext from '../context/parser/async';\nimport type { SerovalMode } from '../plugin';\n\nexport type AsyncParserContextOptions = Omit<BaseParserContextOptions, 'refs'>;\n\nexport default class AsyncParserContext extends BaseAsyncParserContext {\n  readonly mode: SerovalMode = 'vanilla';\n}\n", "import type { BaseDeserializerOptions } from '../context/deserializer';\nimport BaseDeserializerContext from '../context/deserializer';\nimport type { SerovalMode } from '../plugin';\n\nexport interface VanillaDeserializerContextOptions\n  extends Omit<BaseDeserializerOptions, 'refs'> {\n  markedRefs: number[] | Set<number>;\n}\n\nexport default class VanillaDeserializerContext extends BaseDeserializerContext {\n  readonly mode: SerovalMode = 'vanilla';\n\n  marked: Set<number>;\n\n  constructor(options: VanillaDeserializerContextOptions) {\n    super(options);\n    this.marked = new Set(options.markedRefs);\n  }\n\n  assignIndexedValue<T>(index: number, value: T): T {\n    if (this.marked.has(index)) {\n      this.refs.set(index, value);\n    }\n    return value;\n  }\n}\n", "// Written by https://github.com/DylanPiercey and is distributed under the MIT license.\nconst REF_START_CHARS = /* @__PURE__ */ 'hjkmoquxzABCDEFGHIJKLNPQRTUVWXYZ$_'; // Avoids chars that could evaluate to a reserved word.\nconst REF_START_CHARS_LEN = /* @__PURE__ */ REF_START_CHARS.length;\nconst REF_CHARS =\n  /* @__PURE__ */ 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789$_';\nconst REF_CHARS_LEN = /* @__PURE__ */ REF_CHARS.length;\n\nexport default function getIdentifier(index: number): string {\n  let mod = index % REF_START_CHARS_LEN;\n  let ref = REF_START_CHARS[mod];\n  index = (index - mod) / REF_START_CHARS_LEN;\n  while (index > 0) {\n    mod = index % REF_CHARS_LEN;\n    ref += REF_CHARS[mod];\n    index = (index - mod) / REF_CHARS_LEN;\n  }\n  return ref;\n}\n", "import { SerovalNodeType } from '../constants';\nimport type { BaseSerializerContextOptions } from '../context/serializer';\nimport BaseSerializerContext from '../context/serializer';\nimport { SerovalUnsupportedNodeError } from '../errors';\nimport type { SerovalMode } from '../plugin';\nimport type {\n  SerovalNode,\n  SerovalPromiseConstructorNode,\n  SerovalPromiseRejectNode,\n  SerovalPromiseResolveNode,\n} from '../types';\nimport getIdentifier from '../utils/get-identifier';\n\nexport type VanillaSerializerContextOptions = BaseSerializerContextOptions;\n\nexport default class VanillaSerializerContext extends BaseSerializerContext {\n  readonly mode: SerovalMode = 'vanilla';\n\n  /**\n   * Map tree refs to actual refs\n   * @private\n   */\n  valid = new Map<number, number>();\n\n  /**\n   * Variables\n   * @private\n   */\n  vars: string[] = [];\n\n  /**\n   * Creates the reference param (identifier) from the given reference ID\n   * Calling this function means the value has been referenced somewhere\n   */\n  getRefParam(index: number): string {\n    /**\n     * Creates a new reference ID from a given reference ID\n     * This new reference ID means that the reference itself\n     * has been referenced at least once, and is used to generate\n     * the variables\n     */\n    let actualIndex = this.valid.get(index);\n    if (actualIndex == null) {\n      actualIndex = this.valid.size;\n      this.valid.set(index, actualIndex);\n    }\n    let identifier = this.vars[actualIndex];\n    if (identifier == null) {\n      identifier = getIdentifier(actualIndex);\n      this.vars[actualIndex] = identifier;\n    }\n    return identifier;\n  }\n\n  protected assignIndexedValue(index: number, value: string): string {\n    if (this.isMarked(index)) {\n      return this.getRefParam(index) + '=' + value;\n    }\n    return value;\n  }\n\n  protected serializePromiseConstructor(\n    node: SerovalPromiseConstructorNode,\n  ): string {\n    throw new SerovalUnsupportedNodeError(node);\n  }\n\n  protected serializePromiseResolve(node: SerovalPromiseResolveNode): string {\n    throw new SerovalUnsupportedNodeError(node);\n  }\n\n  protected serializePromiseReject(node: SerovalPromiseRejectNode): string {\n    throw new SerovalUnsupportedNodeError(node);\n  }\n\n  serializeTop(tree: SerovalNode): string {\n    const result = this.serialize(tree);\n    // Shared references detected\n    if (tree.i != null && this.vars.length) {\n      const patches = this.resolvePatches();\n      let body = result;\n      if (patches) {\n        // Get (or create) a ref from the source\n        const index = this.getRefParam(tree.i);\n        body = result + ',' + patches + index;\n        if (!result.startsWith(index + '=')) {\n          body = index + '=' + body;\n        }\n        body = '(' + body + ')';\n      }\n      return '(' + this.createFunction(this.vars, body) + ')()';\n    }\n    if (tree.t === SerovalNodeType.Object) {\n      return '(' + result + ')';\n    }\n    return result;\n  }\n}\n", "import BaseSyncParserContext from '../context/parser/sync';\nimport type { BaseParserContextOptions } from '../context/parser';\nimport type { SerovalMode } from '../plugin';\n\nexport type SyncParserContextOptions = Omit<BaseParserContextOptions, 'refs'>;\n\nexport default class SyncParserContext extends BaseSyncParserContext {\n  readonly mode: SerovalMode = 'vanilla';\n}\n", "import { type PluginAccessOptions, resolvePlugins } from '../plugin';\nimport type { SerovalNode } from '../types';\nimport type { AsyncParserContextOptions } from './async';\nimport AsyncParserContext from './async';\nimport VanillaDeserializerContext from './deserializer';\nimport VanillaSerializerContext from './serializer';\nimport type { SyncParserContextOptions } from './sync';\nimport SyncParserContext from './sync';\n\nexport function serialize<T>(\n  source: T,\n  options: SyncParserContextOptions = {},\n): string {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = new SyncParserContext({\n    plugins,\n    disabledFeatures: options.disabledFeatures,\n  });\n  const tree = ctx.parseTop(source);\n  const serial = new VanillaSerializerContext({\n    plugins,\n    features: ctx.features,\n    markedRefs: ctx.marked,\n  });\n  return serial.serializeTop(tree);\n}\n\nexport async function serializeAsync<T>(\n  source: T,\n  options: AsyncParserContextOptions = {},\n): Promise<string> {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = new AsyncParserContext({\n    plugins,\n    disabledFeatures: options.disabledFeatures,\n  });\n  const tree = await ctx.parseTop(source);\n  const serial = new VanillaSerializerContext({\n    plugins,\n    features: ctx.features,\n    markedRefs: ctx.marked,\n  });\n  return serial.serializeTop(tree);\n}\n\nexport function deserialize<T>(source: string): T {\n  return (0, eval)(source) as T;\n}\n\nexport interface SerovalJSON {\n  t: SerovalNode;\n  f: number;\n  m: number[];\n}\n\nexport function toJSON<T>(\n  source: T,\n  options: SyncParserContextOptions = {},\n): SerovalJSON {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = new SyncParserContext({\n    plugins,\n    disabledFeatures: options.disabledFeatures,\n  });\n  return {\n    t: ctx.parseTop(source),\n    f: ctx.features,\n    m: Array.from(ctx.marked),\n  };\n}\n\nexport async function toJSONAsync<T>(\n  source: T,\n  options: AsyncParserContextOptions = {},\n): Promise<SerovalJSON> {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = new AsyncParserContext({\n    plugins,\n    disabledFeatures: options.disabledFeatures,\n  });\n  return {\n    t: await ctx.parseTop(source),\n    f: ctx.features,\n    m: Array.from(ctx.marked),\n  };\n}\n\nexport function compileJSON(\n  source: SerovalJSON,\n  options: PluginAccessOptions = {},\n): string {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = new VanillaSerializerContext({\n    plugins,\n    features: source.f,\n    markedRefs: source.m,\n  });\n  return ctx.serializeTop(source.t);\n}\n\nexport function fromJSON<T>(\n  source: SerovalJSON,\n  options: PluginAccessOptions = {},\n): T {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = new VanillaDeserializerContext({\n    plugins,\n    markedRefs: source.m,\n  });\n  return ctx.deserializeTop(source.t) as T;\n}\n", "import { crossSerializeStream } from './cross';\nimport {\n  resolvePlugins,\n  type Plugin,\n  type PluginAccessOptions,\n} from './plugin';\nimport { serializeString } from './string';\n\nexport interface SerializerOptions extends PluginAccessOptions {\n  globalIdentifier: string;\n  scopeId?: string;\n  disabledFeatures?: number;\n  onData: (result: string) => void;\n  onError: (error: unknown) => void;\n  onDone?: () => void;\n}\n\nexport default class Serializer {\n  private alive = true;\n\n  private flushed = false;\n\n  private done = false;\n\n  private pending = 0;\n\n  private cleanups: (() => void)[] = [];\n\n  private refs = new Map<unknown, number>();\n\n  private plugins?: Plugin<any, any>[];\n\n  constructor(private options: SerializerOptions) {\n    this.plugins = resolvePlugins(options.plugins);\n  }\n\n  keys = new Set<string>();\n\n  write(key: string, value: unknown): void {\n    if (this.alive && !this.flushed) {\n      this.pending++;\n      this.keys.add(key);\n      this.cleanups.push(\n        crossSerializeStream(value, {\n          plugins: this.plugins,\n          scopeId: this.options.scopeId,\n          refs: this.refs,\n          disabledFeatures: this.options.disabledFeatures,\n          onError: this.options.onError,\n          onSerialize: (data, initial) => {\n            if (this.alive) {\n              this.options.onData(\n                initial\n                  ? this.options.globalIdentifier +\n                      '[\"' +\n                      serializeString(key) +\n                      '\"]=' +\n                      data\n                  : data,\n              );\n            }\n          },\n          onDone: () => {\n            if (this.alive) {\n              this.pending--;\n              if (\n                this.pending <= 0 &&\n                this.flushed &&\n                !this.done &&\n                this.options.onDone\n              ) {\n                this.options.onDone();\n                this.done = true;\n              }\n            }\n          },\n        }),\n      );\n    }\n  }\n\n  ids = 0;\n\n  private getNextID(): string {\n    while (this.keys.has('' + this.ids)) {\n      this.ids++;\n    }\n    return '' + this.ids;\n  }\n\n  push(value: unknown): string {\n    const newID = this.getNextID();\n    this.write(newID, value);\n    return newID;\n  }\n\n  flush(): void {\n    if (this.alive) {\n      this.flushed = true;\n      if (this.pending <= 0 && !this.done && this.options.onDone) {\n        this.options.onDone();\n        this.done = true;\n      }\n    }\n  }\n\n  close(): void {\n    if (this.alive) {\n      for (let i = 0, len = this.cleanups.length; i < len; i++) {\n        this.cleanups[i]();\n      }\n      if (!this.done && this.options.onDone) {\n        this.options.onDone();\n        this.done = true;\n      }\n      this.alive = false;\n    }\n  }\n}\n", "import type { SerovalNode } from 'seroval';\nimport { createPlugin } from 'seroval';\n\nfunction resolveAbortSignalResult(\n  this: AbortSignal,\n  resolve: (value: any) => void,\n): void {\n  resolve(this.reason);\n}\n\nfunction resolveAbortSignal(\n  this: AbortSignal,\n  resolve: (value: any) => void,\n): void {\n  this.addEventListener('abort', resolveAbortSignalResult.bind(this, resolve), {\n    once: true,\n  });\n}\n\nexport function abortSignalToPromise(signal: AbortSignal): Promise<any> {\n  return new Promise(resolveAbortSignal.bind(signal));\n}\n\nclass AbortSignalController {\n  controller = new AbortController();\n}\n\nconst AbortSignalControllerPlugin = createPlugin<\n  AbortSignalController,\n  undefined\n>({\n  tag: 'seroval-plugins/web/AbortSignalController',\n  test(value) {\n    // We didn't actually use the AbortController class\n    // directly because of some assumptions\n    return value instanceof AbortSignalController;\n  },\n  parse: {\n    stream() {\n      return undefined;\n    },\n  },\n  serialize(_node) {\n    return 'new AbortController';\n  },\n  deserialize(_node) {\n    return new AbortSignalController();\n  },\n});\n\ninterface AbortSignalAbortNode {\n  controller: SerovalNode;\n  reason: SerovalNode;\n}\n\nclass AbortSignalAbort {\n  constructor(\n    public controller: AbortSignalController,\n    public reason: unknown,\n  ) {}\n}\n\nconst AbortSignalAbortPlugin = createPlugin<\n  AbortSignalAbort,\n  AbortSignalAbortNode\n>({\n  extends: [AbortSignalControllerPlugin],\n  tag: 'seroval-plugins/web/AbortSignalAbort',\n  test(value) {\n    return value instanceof AbortSignalAbort;\n  },\n  parse: {\n    stream(value, ctx) {\n      return {\n        controller: ctx.parse(value.controller),\n        reason: ctx.parse(value.reason),\n      };\n    },\n  },\n  serialize(node, ctx) {\n    return (\n      ctx.serialize(node.controller) +\n      '.abort(' +\n      ctx.serialize(node.reason) +\n      ')'\n    );\n  },\n  deserialize(node, ctx) {\n    const controller = ctx.deserialize(\n      node.controller,\n    ) as AbortSignalController;\n    const reason = ctx.deserialize(node.reason);\n    controller.controller.abort(reason);\n    return new AbortSignalAbort(controller, reason);\n  },\n});\n\nconst enum AbortSignalState {\n  Pending = 0,\n  Aborted = 1,\n  Streaming = 2,\n}\n\ntype AbortSignalNode =\n  | { type: AbortSignalState.Pending }\n  | { type: AbortSignalState.Aborted; reason: SerovalNode }\n  | { type: AbortSignalState.Streaming; controller: SerovalNode };\n\nconst AbortSignalPlugin = createPlugin<AbortSignal, AbortSignalNode>({\n  tag: 'seroval-plugins/web/AbortSignal',\n  extends: [AbortSignalAbortPlugin],\n  test(value) {\n    if (typeof AbortSignal === 'undefined') {\n      return false;\n    }\n    return value instanceof AbortSignal;\n  },\n  parse: {\n    sync(value, ctx) {\n      if (value.aborted) {\n        return {\n          type: AbortSignalState.Aborted,\n          reason: ctx.parse(value.reason),\n        };\n      }\n      return {\n        type: AbortSignalState.Pending,\n      };\n    },\n    async async(value, ctx) {\n      if (value.aborted) {\n        return {\n          type: AbortSignalState.Aborted,\n          reason: await ctx.parse(value.reason),\n        };\n      }\n      const result = await abortSignalToPromise(value);\n      return {\n        type: AbortSignalState.Aborted,\n        reason: await ctx.parse(result),\n      };\n    },\n    stream(value, ctx) {\n      if (value.aborted) {\n        return {\n          type: AbortSignalState.Aborted,\n          reason: ctx.parse(value.reason),\n        };\n      }\n      const controller = new AbortSignalController();\n\n      ctx.pushPendingState();\n      value.addEventListener(\n        'abort',\n        () => {\n          const result = ctx.parseWithError(\n            new AbortSignalAbort(controller, value.reason),\n          );\n          if (result) {\n            ctx.onParse(result);\n          }\n          ctx.popPendingState();\n        },\n        { once: true },\n      );\n\n      return {\n        type: AbortSignalState.Streaming,\n        controller: ctx.parse(controller),\n      };\n    },\n  },\n  serialize(node, ctx) {\n    if (node.type === AbortSignalState.Pending) {\n      return '(new AbortController).signal';\n    }\n    if (node.type === AbortSignalState.Aborted) {\n      return 'AbortSignal.abort(' + ctx.serialize(node.reason) + ')';\n    }\n    return '(' + ctx.serialize(node.controller) + ').signal';\n  },\n  deserialize(node, ctx) {\n    if (node.type === AbortSignalState.Pending) {\n      const controller = new AbortController();\n      return controller.signal;\n    }\n    if (node.type === AbortSignalState.Aborted) {\n      return AbortSignal.abort(ctx.deserialize(node.reason));\n    }\n    const controller = ctx.deserialize(\n      node.controller,\n    ) as AbortSignalController;\n    return controller.controller.signal;\n  },\n});\n\nexport default AbortSignalPlugin;\n", "import type { SerovalNode } from 'seroval';\nimport { createPlugin } from 'seroval';\n\ninterface BlobNode {\n  type: SerovalNode;\n  buffer: SerovalNode;\n}\n\nconst BlobPlugin = /* @__PURE__ */ createPlugin<Blob, BlobNode>({\n  tag: 'seroval-plugins/web/Blob',\n  test(value) {\n    if (typeof Blob === 'undefined') {\n      return false;\n    }\n    return value instanceof Blob;\n  },\n  parse: {\n    async async(value, ctx) {\n      return {\n        type: await ctx.parse(value.type),\n        buffer: await ctx.parse(await value.arrayBuffer()),\n      };\n    },\n  },\n  serialize(node, ctx) {\n    return (\n      'new Blob([' +\n      ctx.serialize(node.buffer) +\n      '],{type:' +\n      ctx.serialize(node.type) +\n      '})'\n    );\n  },\n  deserialize(node, ctx) {\n    return new Blob([ctx.deserialize(node.buffer) as ArrayBuffer], {\n      type: ctx.deserialize(node.type) as string,\n    });\n  },\n});\n\nexport default BlobPlugin;\n", "import type { SerovalNode } from 'seroval';\nimport { createPlugin } from 'seroval';\n\nfunction createCustomEventOptions(current: CustomEvent): CustomEventInit {\n  return {\n    detail: current.detail as unknown,\n    bubbles: current.bubbles,\n    cancelable: current.cancelable,\n    composed: current.composed,\n  };\n}\n\ninterface CustomEventNode {\n  type: SerovalNode;\n  options: SerovalNode;\n}\n\nconst CustomEventPlugin = /* @__PURE__ */ createPlugin<\n  CustomEvent,\n  CustomEventNode\n>({\n  tag: 'seroval-plugins/web/CustomEvent',\n  test(value) {\n    if (typeof CustomEvent === 'undefined') {\n      return false;\n    }\n    return value instanceof CustomEvent;\n  },\n  parse: {\n    sync(value, ctx) {\n      return {\n        type: ctx.parse(value.type),\n        options: ctx.parse(createCustomEventOptions(value)),\n      };\n    },\n    async async(value, ctx) {\n      return {\n        type: await ctx.parse(value.type),\n        options: await ctx.parse(createCustomEventOptions(value)),\n      };\n    },\n    stream(value, ctx) {\n      return {\n        type: ctx.parse(value.type),\n        options: ctx.parse(createCustomEventOptions(value)),\n      };\n    },\n  },\n  serialize(node, ctx) {\n    return (\n      'new CustomEvent(' +\n      ctx.serialize(node.type) +\n      ',' +\n      ctx.serialize(node.options) +\n      ')'\n    );\n  },\n  deserialize(node, ctx) {\n    return new CustomEvent(\n      ctx.deserialize(node.type) as string,\n      ctx.deserialize(node.options) as CustomEventInit,\n    );\n  },\n});\n\nexport default CustomEventPlugin;\n", "import type { SerovalNode } from 'seroval';\nimport { createPlugin } from 'seroval';\n\ninterface DOMExceptionNode {\n  name: SerovalNode;\n  message: SerovalNode;\n}\n\nconst DOMExceptionPlugin = /* @__PURE__ */ createPlugin<\n  DOMException,\n  DOMExceptionNode\n>({\n  tag: 'seroval-plugins/web/DOMException',\n  test(value) {\n    if (typeof DOMException === 'undefined') {\n      return false;\n    }\n    return value instanceof DOMException;\n  },\n  parse: {\n    sync(value, ctx) {\n      return {\n        name: ctx.parse(value.name),\n        message: ctx.parse(value.message),\n      };\n    },\n    async async(value, ctx) {\n      return {\n        name: await ctx.parse(value.name),\n        message: await ctx.parse(value.message),\n      };\n    },\n    stream(value, ctx) {\n      return {\n        name: ctx.parse(value.name),\n        message: ctx.parse(value.message),\n      };\n    },\n  },\n  serialize(node, ctx) {\n    return (\n      'new DOMException(' +\n      ctx.serialize(node.message) +\n      ',' +\n      ctx.serialize(node.name) +\n      ')'\n    );\n  },\n  deserialize(node, ctx) {\n    return new DOMException(\n      ctx.deserialize(node.message) as string,\n      ctx.deserialize(node.name) as string,\n    );\n  },\n});\n\nexport default DOMExceptionPlugin;\n", "import type { SerovalNode } from 'seroval';\nimport { createPlugin } from 'seroval';\n\nfunction createEventOptions(current: Event): EventInit {\n  return {\n    bubbles: current.bubbles,\n    cancelable: current.cancelable,\n    composed: current.composed,\n  };\n}\n\ninterface EventNode {\n  type: SerovalNode;\n  options: SerovalNode;\n}\n\nconst EventPlugin = /* @__PURE__ */ createPlugin<Event, EventNode>({\n  tag: 'seroval-plugins/web/Event',\n  test(value) {\n    if (typeof Event === 'undefined') {\n      return false;\n    }\n    return value instanceof Event;\n  },\n  parse: {\n    sync(value, ctx) {\n      return {\n        type: ctx.parse(value.type),\n        options: ctx.parse(createEventOptions(value)),\n      };\n    },\n    async async(value, ctx) {\n      return {\n        type: await ctx.parse(value.type),\n        options: await ctx.parse(createEventOptions(value)),\n      };\n    },\n    stream(value, ctx) {\n      return {\n        type: ctx.parse(value.type),\n        options: ctx.parse(createEventOptions(value)),\n      };\n    },\n  },\n  serialize(node, ctx) {\n    return (\n      'new Event(' +\n      ctx.serialize(node.type) +\n      ',' +\n      ctx.serialize(node.options) +\n      ')'\n    );\n  },\n  deserialize(node, ctx) {\n    return new Event(\n      ctx.deserialize(node.type) as string,\n      ctx.deserialize(node.options) as EventInit,\n    );\n  },\n});\n\nexport default EventPlugin;\n", "import type { SerovalNode } from 'seroval';\nimport { createPlugin } from 'seroval';\n\ninterface FileNode {\n  name: SerovalNode;\n  options: SerovalNode;\n  buffer: SerovalNode;\n}\n\nconst FilePlugin = /* @__PURE__ */ createPlugin<File, FileNode>({\n  tag: 'seroval-plugins/web/File',\n  test(value) {\n    if (typeof File === 'undefined') {\n      return false;\n    }\n    return value instanceof File;\n  },\n  parse: {\n    async async(value, ctx) {\n      return {\n        name: await ctx.parse(value.name),\n        options: await ctx.parse({\n          type: value.type,\n          lastModified: value.lastModified,\n        }),\n        buffer: await ctx.parse(await value.arrayBuffer()),\n      };\n    },\n  },\n  serialize(node, ctx) {\n    return (\n      'new File([' +\n      ctx.serialize(node.buffer) +\n      '],' +\n      ctx.serialize(node.name) +\n      ',' +\n      ctx.serialize(node.options) +\n      ')'\n    );\n  },\n  deserialize(node, ctx) {\n    return new File(\n      [ctx.deserialize(node.buffer) as ArrayBuffer],\n      ctx.deserialize(node.name) as string,\n      ctx.deserialize(node.options) as FilePropertyBag,\n    );\n  },\n});\n\nexport default FilePlugin;\n", "import type { SerovalNode } from 'seroval';\nimport { createPlugin } from 'seroval';\nimport FilePlugin from './file';\n\ntype FormDataInit = [key: string, value: FormDataEntryValue][];\n\nfunction convertFormData(instance: FormData): FormDataInit {\n  const items: FormDataInit = [];\n  // biome-ignore lint/complexity/noForEach: <explanation>\n  instance.forEach((value, key) => {\n    items.push([key, value]);\n  });\n  return items;\n}\n\nconst FORM_DATA_FACTORY = {};\n\nconst FormDataFactoryPlugin = /* @__PURE__ */ createPlugin<object, undefined>({\n  tag: 'seroval-plugins/web/FormDataFactory',\n  test(value) {\n    return value === FORM_DATA_FACTORY;\n  },\n  parse: {\n    sync() {\n      return undefined;\n    },\n    async async() {\n      return await Promise.resolve(undefined);\n    },\n    stream() {\n      return undefined;\n    },\n  },\n  serialize(_node, ctx) {\n    return ctx.createEffectfulFunction(\n      ['e', 'f', 'i', 's', 't'],\n      'f=new FormData;for(i=0,s=e.length;i<s;i++)f.append((t=e[i])[0],t[1]);return f',\n    );\n  },\n  deserialize() {\n    return FORM_DATA_FACTORY;\n  },\n});\n\ninterface FormDataNode {\n  factory: SerovalNode;\n  entries: SerovalNode;\n}\n\nconst FormDataPlugin = /* @__PURE__ */ createPlugin<FormData, FormDataNode>({\n  tag: 'seroval-plugins/web/FormData',\n  extends: [FilePlugin, FormDataFactoryPlugin],\n  test(value) {\n    if (typeof FormData === 'undefined') {\n      return false;\n    }\n    return value instanceof FormData;\n  },\n  parse: {\n    sync(value, ctx) {\n      return {\n        factory: ctx.parse(FORM_DATA_FACTORY),\n        entries: ctx.parse(convertFormData(value)),\n      };\n    },\n    async async(value, ctx) {\n      return {\n        factory: await ctx.parse(FORM_DATA_FACTORY),\n        entries: await ctx.parse(convertFormData(value)),\n      };\n    },\n    stream(value, ctx) {\n      return {\n        factory: ctx.parse(FORM_DATA_FACTORY),\n        entries: ctx.parse(convertFormData(value)),\n      };\n    },\n  },\n  serialize(node, ctx) {\n    return (\n      '(' +\n      ctx.serialize(node.factory) +\n      ')(' +\n      ctx.serialize(node.entries) +\n      ')'\n    );\n  },\n  deserialize(node, ctx) {\n    const instance = new FormData();\n    const entries = ctx.deserialize(node.entries) as FormDataInit;\n    for (let i = 0, len = entries.length; i < len; i++) {\n      const entry = entries[i];\n      instance.append(entry[0], entry[1]);\n    }\n    return instance;\n  },\n});\n\nexport default FormDataPlugin;\n", "import type { SerovalNode } from 'seroval';\nimport { createPlugin } from 'seroval';\n\nfunction convertHeaders(instance: Headers): HeadersInit {\n  const items: HeadersInit = [];\n  // biome-ignore lint/complexity/noForEach: <explanation>\n  instance.forEach((value, key) => {\n    items.push([key, value]);\n  });\n  return items;\n}\n\nconst HeadersPlugin = /* @__PURE__ */ createPlugin<Headers, SerovalNode>({\n  tag: 'seroval-plugins/web/Headers',\n  test(value) {\n    if (typeof Headers === 'undefined') {\n      return false;\n    }\n    return value instanceof Headers;\n  },\n  parse: {\n    sync(value, ctx) {\n      return ctx.parse(convertHeaders(value));\n    },\n    async async(value, ctx) {\n      return await ctx.parse(convertHeaders(value));\n    },\n    stream(value, ctx) {\n      return ctx.parse(convertHeaders(value));\n    },\n  },\n  serialize(node, ctx) {\n    return 'new Headers(' + ctx.serialize(node) + ')';\n  },\n  deserialize(node, ctx) {\n    return new Headers(ctx.deserialize(node) as HeadersInit);\n  },\n});\n\nexport default HeadersPlugin;\n", "import type { SerovalNode } from 'seroval';\nimport { createPlugin } from 'seroval';\n\ninterface ImageDataNode {\n  data: SerovalNode;\n  width: SerovalNode;\n  height: SerovalNode;\n  options: SerovalNode;\n}\n\nconst ImageDataPlugin = /* @__PURE__ */ createPlugin<ImageData, ImageDataNode>({\n  tag: 'seroval-plugins/web/ImageData',\n  test(value) {\n    if (typeof ImageData === 'undefined') {\n      return false;\n    }\n    return value instanceof ImageData;\n  },\n  parse: {\n    sync(value, ctx) {\n      return {\n        data: ctx.parse(value.data),\n        width: ctx.parse(value.width),\n        height: ctx.parse(value.height),\n        options: ctx.parse({\n          colorSpace: value.colorSpace,\n        }),\n      };\n    },\n    async async(value, ctx) {\n      return {\n        data: await ctx.parse(value.data),\n        width: await ctx.parse(value.width),\n        height: await ctx.parse(value.height),\n        options: await ctx.parse({\n          colorSpace: value.colorSpace,\n        }),\n      };\n    },\n    stream(value, ctx) {\n      return {\n        data: ctx.parse(value.data),\n        width: ctx.parse(value.width),\n        height: ctx.parse(value.height),\n        options: ctx.parse({\n          colorSpace: value.colorSpace,\n        }),\n      };\n    },\n  },\n  serialize(node, ctx) {\n    return (\n      'new ImageData(' +\n      ctx.serialize(node.data) +\n      ',' +\n      ctx.serialize(node.width) +\n      ',' +\n      ctx.serialize(node.height) +\n      ',' +\n      ctx.serialize(node.options) +\n      ')'\n    );\n  },\n  deserialize(node, ctx) {\n    return new ImageData(\n      ctx.deserialize(node.data) as Uint8ClampedArray,\n      ctx.deserialize(node.width) as number,\n      ctx.deserialize(node.height) as number,\n      ctx.deserialize(node.options) as ImageDataSettings,\n    );\n  },\n});\n\nexport default ImageDataPlugin;\n", "import type { SerovalNode, Stream } from 'seroval';\nimport { createPlugin, createStream } from 'seroval';\n\nconst READABLE_STREAM_FACTORY = {};\n\nconst ReadableStreamFactoryPlugin = /* @__PURE__ */ createPlugin<\n  object,\n  undefined\n>({\n  tag: 'seroval-plugins/web/ReadableStreamFactory',\n  test(value) {\n    return value === READABLE_STREAM_FACTORY;\n  },\n  parse: {\n    sync() {\n      return undefined;\n    },\n    async async() {\n      return await Promise.resolve(undefined);\n    },\n    stream() {\n      return undefined;\n    },\n  },\n  serialize(_node, ctx) {\n    return ctx.createFunction(\n      ['d'],\n      'new ReadableStream({start:' +\n        ctx.createEffectfulFunction(\n          ['c'],\n          'd.on({next:' +\n            ctx.createEffectfulFunction(['v'], 'try{c.enqueue(v)}catch{}') +\n            ',throw:' +\n            ctx.createEffectfulFunction(['v'], 'c.error(v)') +\n            ',return:' +\n            ctx.createEffectfulFunction([], 'try{c.close()}catch{}') +\n            '})',\n        ) +\n        '})',\n    );\n  },\n  deserialize() {\n    return READABLE_STREAM_FACTORY;\n  },\n});\n\nfunction toStream<T>(value: ReadableStream<T>): Stream<T | undefined> {\n  const stream = createStream<T | undefined>();\n\n  const reader = value.getReader();\n\n  async function push(): Promise<void> {\n    try {\n      const result = await reader.read();\n      if (result.done) {\n        stream.return(result.value);\n      } else {\n        stream.next(result.value);\n        await push();\n      }\n    } catch (error) {\n      stream.throw(error);\n    }\n  }\n\n  push().catch(() => {\n    //\n  });\n\n  return stream;\n}\n\ninterface ReadableStreamNode {\n  factory: SerovalNode;\n  stream: SerovalNode;\n}\n\nconst ReadableStreamPlugin = /* @__PURE__ */ createPlugin<\n  ReadableStream,\n  ReadableStreamNode\n>({\n  tag: 'seroval/plugins/web/ReadableStream',\n  extends: [ReadableStreamFactoryPlugin],\n  test(value) {\n    if (typeof ReadableStream === 'undefined') {\n      return false;\n    }\n    return value instanceof ReadableStream;\n  },\n  parse: {\n    sync(_value, ctx) {\n      return {\n        factory: ctx.parse(READABLE_STREAM_FACTORY),\n        stream: ctx.parse(createStream()),\n      };\n    },\n    async async(value, ctx) {\n      return {\n        factory: await ctx.parse(READABLE_STREAM_FACTORY),\n        stream: await ctx.parse(toStream(value)),\n      };\n    },\n    stream(value, ctx) {\n      return {\n        factory: ctx.parse(READABLE_STREAM_FACTORY),\n        stream: ctx.parse(toStream(value)),\n      };\n    },\n  },\n  serialize(node, ctx) {\n    return (\n      '(' +\n      ctx.serialize(node.factory) +\n      ')(' +\n      ctx.serialize(node.stream) +\n      ')'\n    );\n  },\n  deserialize(node, ctx) {\n    const stream = ctx.deserialize(node.stream) as Stream<any>;\n    return new ReadableStream({\n      start(controller): void {\n        stream.on({\n          next(value) {\n            try {\n              controller.enqueue(value);\n            } catch {}\n          },\n          throw(value) {\n            controller.error(value);\n          },\n          return() {\n            try {\n              controller.close();\n            } catch {}\n          },\n        });\n      },\n    });\n  },\n});\n\nexport default ReadableStreamPlugin;\n", "import type { SerovalNode } from 'seroval';\nimport { createPlugin } from 'seroval';\nimport ReadableStreamPlugin from './readable-stream';\nimport HeadersPlugin from './headers';\n\nfunction createRequestOptions(\n  current: Request,\n  body: ArrayBuffer | ReadableStream | null,\n): RequestInit {\n  return {\n    body,\n    cache: current.cache,\n    credentials: current.credentials,\n    headers: current.headers,\n    integrity: current.integrity,\n    keepalive: current.keepalive,\n    method: current.method,\n    mode: current.mode,\n    redirect: current.redirect,\n    referrer: current.referrer,\n    referrerPolicy: current.referrerPolicy,\n  };\n}\n\ninterface RequestNode {\n  url: SerovalNode;\n  options: SerovalNode;\n}\n\nconst RequestPlugin = /* @__PURE__ */ createPlugin<Request, RequestNode>({\n  tag: 'seroval-plugins/web/Request',\n  extends: [ReadableStreamPlugin, HeadersPlugin],\n  test(value) {\n    if (typeof Request === 'undefined') {\n      return false;\n    }\n    return value instanceof Request;\n  },\n  parse: {\n    async async(value, ctx) {\n      return {\n        url: await ctx.parse(value.url),\n        options: await ctx.parse(\n          createRequestOptions(\n            value,\n            value.body ? await value.clone().arrayBuffer() : null,\n          ),\n        ),\n      };\n    },\n    stream(value, ctx) {\n      return {\n        url: ctx.parse(value.url),\n        options: ctx.parse(createRequestOptions(value, value.clone().body)),\n      };\n    },\n  },\n  serialize(node, ctx) {\n    return (\n      'new Request(' +\n      ctx.serialize(node.url) +\n      ',' +\n      ctx.serialize(node.options) +\n      ')'\n    );\n  },\n  deserialize(node, ctx) {\n    return new Request(\n      ctx.deserialize(node.url) as string,\n      ctx.deserialize(node.options) as RequestInit,\n    );\n  },\n});\n\nexport default RequestPlugin;\n", "import type { SerovalNode } from 'seroval';\nimport { createPlugin } from 'seroval';\nimport ReadableStreamPlugin from './readable-stream';\nimport HeadersPlugin from './headers';\n\nfunction createResponseOptions(current: Response): ResponseInit {\n  return {\n    headers: current.headers,\n    status: current.status,\n    statusText: current.statusText,\n  };\n}\n\ninterface ResponseNode {\n  body: SerovalNode;\n  options: SerovalNode;\n}\n\nconst ResponsePlugin = /* @__PURE__ */ createPlugin<Response, ResponseNode>({\n  tag: 'seroval-plugins/web/Response',\n  extends: [ReadableStreamPlugin, HeadersPlugin],\n  test(value) {\n    if (typeof Response === 'undefined') {\n      return false;\n    }\n    return value instanceof Response;\n  },\n  parse: {\n    async async(value, ctx) {\n      return {\n        body: await ctx.parse(\n          value.body ? await value.clone().arrayBuffer() : null,\n        ),\n        options: await ctx.parse(createResponseOptions(value)),\n      };\n    },\n    stream(value, ctx) {\n      return {\n        body: ctx.parse(value.clone().body),\n        options: ctx.parse(createResponseOptions(value)),\n      };\n    },\n  },\n  serialize(node, ctx) {\n    return (\n      'new Response(' +\n      ctx.serialize(node.body) +\n      ',' +\n      ctx.serialize(node.options) +\n      ')'\n    );\n  },\n  deserialize(node, ctx) {\n    return new Response(\n      ctx.deserialize(node.body) as BodyInit,\n      ctx.deserialize(node.options) as ResponseInit,\n    );\n  },\n});\n\nexport default ResponsePlugin;\n", "import type { SerovalNode } from 'seroval';\nimport { createPlugin } from 'seroval';\n\nconst URLPlugin = /* @__PURE__ */ createPlugin<URL, SerovalNode>({\n  tag: 'seroval-plugins/web/URL',\n  test(value) {\n    if (typeof URL === 'undefined') {\n      return false;\n    }\n    return value instanceof URL;\n  },\n  parse: {\n    sync(value, ctx) {\n      return ctx.parse(value.href);\n    },\n    async async(value, ctx) {\n      return await ctx.parse(value.href);\n    },\n    stream(value, ctx) {\n      return ctx.parse(value.href);\n    },\n  },\n  serialize(node, ctx) {\n    return 'new URL(' + ctx.serialize(node) + ')';\n  },\n  deserialize(node, ctx) {\n    return new URL(ctx.deserialize(node) as string);\n  },\n});\n\nexport default URLPlugin;\n", "import type { SerovalNode } from 'seroval';\nimport { createPlugin } from 'seroval';\n\nconst URLSearchParamsPlugin = /* @__PURE__ */ createPlugin<\n  URLSearchParams,\n  SerovalNode\n>({\n  tag: 'seroval-plugins/web/URLSearchParams',\n  test(value) {\n    if (typeof URLSearchParams === 'undefined') {\n      return false;\n    }\n    return value instanceof URLSearchParams;\n  },\n  parse: {\n    sync(value, ctx) {\n      return ctx.parse(value.toString());\n    },\n    async async(value, ctx) {\n      return await ctx.parse(value.toString());\n    },\n    stream(value, ctx) {\n      return ctx.parse(value.toString());\n    },\n  },\n  serialize(node, ctx) {\n    return 'new URLSearchParams(' + ctx.serialize(node) + ')';\n  },\n  deserialize(node, ctx) {\n    return new URLSearchParams(ctx.deserialize(node) as string);\n  },\n});\n\nexport default URLSearchParamsPlugin;\n", "import { createPlugin } from 'seroval'\nimport type { SerovalNode } from 'seroval'\n\nexport interface ErrorNode {\n  message: SerovalNode\n}\n\n/**\n * this plugin serializes only the `message` part of an Error\n * this helps with serializing e.g. a ZodError which has functions attached that cannot be serialized\n */\nexport const ShallowErrorPlugin = /* @__PURE__ */ createPlugin<\n  Error,\n  ErrorNode\n>({\n  tag: '$TSR/Error',\n  test(value) {\n    return value instanceof Error\n  },\n  parse: {\n    sync(value, ctx) {\n      return {\n        message: ctx.parse(value.message),\n      }\n    },\n    async async(value, ctx) {\n      return {\n        message: await ctx.parse(value.message),\n      }\n    },\n    stream(value, ctx) {\n      return {\n        message: ctx.parse(value.message),\n      }\n    },\n  },\n  serialize(node, ctx) {\n    return 'new Error(' + ctx.serialize(node.message) + ')'\n  },\n  deserialize(node, ctx) {\n    return new Error(ctx.deserialize(node.message) as string)\n  },\n})\n", "import {\n  dehydrate as queryDehydrate,\n  hydrate as queryHydrate,\n} from '@tanstack/query-core'\nimport { isRedirect } from '@tanstack/router-core'\nimport type { AnyRouter } from '@tanstack/router-core'\nimport type {\n  QueryClient,\n  DehydratedState as QueryDehydratedState,\n} from '@tanstack/query-core'\n\nexport type RouterSsrQueryOptions<TRouter extends AnyRouter> = {\n  router: TRouter\n  queryClient: QueryClient\n\n  /**\n   * If `true`, the QueryClient will handle errors thrown by `redirect()` inside of mutations and queries.\n   *\n   * @default true\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/api/router/redirectFunction)\n   */\n  handleRedirects?: boolean\n}\n\ntype DehydratedRouterQueryState = {\n  dehydratedQueryClient?: QueryDehydratedState\n  queryStream: ReadableStream<QueryDehydratedState>\n}\n\nexport function setupCoreRouterSsrQueryIntegration<TRouter extends AnyRouter>({\n  router,\n  queryClient,\n  handleRedirects = true,\n}: RouterSsrQueryOptions<TRouter>) {\n  const ogHydrate = router.options.hydrate\n  const ogDehydrate = router.options.dehydrate\n\n  if (router.isServer) {\n    const sentQueries = new Set<string>()\n    const queryStream = createPushableStream()\n\n    router.options.dehydrate =\n      async (): Promise<DehydratedRouterQueryState> => {\n        router.serverSsr!.onRenderFinished(() => queryStream.close())\n        const ogDehydrated = await ogDehydrate?.()\n\n        const dehydratedRouter = {\n          ...ogDehydrated,\n          // prepare the stream for queries coming up during rendering\n          queryStream: queryStream.stream,\n        }\n\n        const dehydratedQueryClient = queryDehydrate(queryClient)\n        if (dehydratedQueryClient.queries.length > 0) {\n          dehydratedQueryClient.queries.forEach((query) => {\n            sentQueries.add(query.queryHash)\n          })\n          dehydratedRouter.dehydratedQueryClient = dehydratedQueryClient\n        }\n\n        return dehydratedRouter\n      }\n\n    const ogClientOptions = queryClient.getDefaultOptions()\n    queryClient.setDefaultOptions({\n      ...ogClientOptions,\n      dehydrate: {\n        shouldDehydrateQuery: () => true,\n        ...ogClientOptions.dehydrate,\n      },\n    })\n\n    queryClient.getQueryCache().subscribe((event) => {\n      // before rendering starts, we do not stream individual queries\n      // instead we dehydrate the entire query client in router's dehydrate()\n      // if attachRouterServerSsrUtils() has not been called yet, `router.serverSsr` will be undefined and we also do not stream\n      if (!router.serverSsr?.isDehydrated()) {\n        return\n      }\n      if (sentQueries.has(event.query.queryHash)) {\n        return\n      }\n      // promise not yet set on the query, so we cannot stream it yet\n      if (!event.query.promise) {\n        return\n      }\n      if (queryStream.isClosed()) {\n        console.warn(\n          `tried to stream query ${event.query.queryHash} after stream was already closed`,\n        )\n        return\n      }\n      sentQueries.add(event.query.queryHash)\n      queryStream.enqueue(\n        queryDehydrate(queryClient, {\n          shouldDehydrateQuery: (query) => {\n            if (query.queryHash === event.query.queryHash) {\n              return (\n                ogClientOptions.dehydrate?.shouldDehydrateQuery?.(query) ?? true\n              )\n            }\n            return false\n          },\n        }),\n      )\n    })\n    // on the client\n  } else {\n    router.options.hydrate = async (dehydrated: DehydratedRouterQueryState) => {\n      await ogHydrate?.(dehydrated)\n      // hydrate the query client with the dehydrated data (if it was dehydrated on the server)\n      if (dehydrated.dehydratedQueryClient) {\n        queryHydrate(queryClient, dehydrated.dehydratedQueryClient)\n      }\n\n      // read the query stream and hydrate the queries as they come in\n      const reader = dehydrated.queryStream.getReader()\n      reader\n        .read()\n        .then(async function handle({ done, value }) {\n          queryHydrate(queryClient, value)\n          if (done) {\n            return\n          }\n          const result = await reader.read()\n          return handle(result)\n        })\n        .catch((err) => {\n          console.error('Error reading query stream:', err)\n        })\n    }\n    if (handleRedirects) {\n      const ogMutationCacheConfig = queryClient.getMutationCache().config\n      queryClient.getMutationCache().config = {\n        ...ogMutationCacheConfig,\n        onError: (error, ...rest) => {\n          if (isRedirect(error)) {\n            error.options._fromLocation = router.state.location\n            return router.navigate(router.resolveRedirect(error).options)\n          }\n\n          return ogMutationCacheConfig.onError?.(error, ...rest)\n        },\n      }\n\n      const ogQueryCacheConfig = queryClient.getQueryCache().config\n      queryClient.getQueryCache().config = {\n        ...ogQueryCacheConfig,\n        onError: (error, ...rest) => {\n          if (isRedirect(error)) {\n            error.options._fromLocation = router.state.location\n            return router.navigate(router.resolveRedirect(error).options)\n          }\n\n          return ogQueryCacheConfig.onError?.(error, ...rest)\n        },\n      }\n    }\n  }\n}\n\ntype PushableStream = {\n  stream: ReadableStream\n  enqueue: (chunk: unknown) => void\n  close: () => void\n  isClosed: () => boolean\n  error: (err: unknown) => void\n}\n\nfunction createPushableStream(): PushableStream {\n  let controllerRef: ReadableStreamDefaultController\n  const stream = new ReadableStream({\n    start(controller) {\n      controllerRef = controller\n    },\n  })\n  let _isClosed = false\n\n  return {\n    stream,\n    enqueue: (chunk) => controllerRef.enqueue(chunk),\n    close: () => {\n      controllerRef.close()\n      _isClosed = true\n    },\n    isClosed: () => _isClosed,\n    error: (err: unknown) => controllerRef.error(err),\n  }\n}\n", "import { Fragment } from 'react'\nimport { QueryClientProvider } from '@tanstack/react-query'\nimport { setupCoreRouterSsrQueryIntegration } from '@tanstack/router-ssr-query-core'\nimport type { RouterSsrQueryOptions } from '@tanstack/router-ssr-query-core'\nimport type { AnyRouter } from '@tanstack/react-router'\n\nexport type Options<TRouter extends AnyRouter> =\n  RouterSsrQueryOptions<TRouter> & {\n    wrapQueryClient?: boolean\n  }\n\nexport function setupRouterSsrQueryIntegration<TRouter extends AnyRouter>(\n  opts: Options<TRouter>,\n) {\n  setupCoreRouterSsrQueryIntegration(opts)\n\n  if (opts.wrapQueryClient === false) {\n    return\n  }\n  const OGWrap = opts.router.options.Wrap || Fragment\n\n  opts.router.options.Wrap = ({ children }) => {\n    return (\n      <QueryClientProvider client={opts.queryClient}>\n        <OGWrap>{children}</OGWrap>\n      </QueryClientProvider>\n    )\n  }\n}\n"],
  "mappings": "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",
  "names": ["Feature", "controller", "createPlugin", "createPlugin", "createPlugin", "createPlugin", "createPlugin", "createPlugin", "createPlugin", "createPlugin", "createPlugin", "createPlugin", "queryDehydrate", "queryHydrate"]
}
