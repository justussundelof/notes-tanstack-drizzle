import {
  QueryClientProvider,
  dehydrate,
  hydrate
} from "./chunk-YW2TINPH.js";
import {
  require_jsx_runtime
} from "./chunk-4ERTSB2Z.js";
import "./chunk-H6MW4HP5.js";
import {
  require_react
} from "./chunk-VCVXMD54.js";
import {
  __toESM
} from "./chunk-7D4SUZUM.js";

// node_modules/@tanstack/react-router-ssr-query/dist/esm/index.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_react = __toESM(require_react());

// node_modules/@tanstack/router-core/dist/esm/utils.js
function isFunction(d) {
  return typeof d === "function";
}
function functionalUpdate(updater, previous) {
  if (isFunction(updater)) {
    return updater(previous);
  }
  return updater;
}
var DECODE_IGNORE_LIST = Array.from(
  (/* @__PURE__ */ new Map([
    ["%", "%25"],
    ["\\", "%5C"]
  ])).values()
);

// node_modules/@tanstack/router-core/dist/esm/scroll-restoration.js
function getSafeSessionStorage() {
  try {
    if (typeof window !== "undefined" && typeof window.sessionStorage === "object") {
      return window.sessionStorage;
    }
  } catch {
  }
  return void 0;
}
var storageKey = "tsr-scroll-restoration-v1_3";
function createScrollRestorationCache() {
  const safeSessionStorage = getSafeSessionStorage();
  if (!safeSessionStorage) {
    return null;
  }
  const persistedState = safeSessionStorage.getItem(storageKey);
  let state = persistedState ? JSON.parse(persistedState) : {};
  return {
    state,
    // This setter is simply to make sure that we set the sessionStorage right
    // after the state is updated. It doesn't necessarily need to be a functional
    // update.
    set: (updater) => (state = functionalUpdate(updater, state) || state, safeSessionStorage.setItem(storageKey, JSON.stringify(state)))
  };
}
var scrollRestorationCache = createScrollRestorationCache();

// node_modules/@tanstack/router-core/dist/esm/qss.js
function encode(obj, stringify = String) {
  const result = new URLSearchParams();
  for (const key in obj) {
    const val = obj[key];
    if (val !== void 0) {
      result.set(key, stringify(val));
    }
  }
  return result.toString();
}
function toValue(str) {
  if (!str) return "";
  if (str === "false") return false;
  if (str === "true") return true;
  return +str * 0 === 0 && +str + "" === str ? +str : str;
}
function decode(str) {
  const searchParams = new URLSearchParams(str);
  const result = {};
  for (const [key, value] of searchParams.entries()) {
    const previousValue = result[key];
    if (previousValue == null) {
      result[key] = toValue(value);
    } else if (Array.isArray(previousValue)) {
      previousValue.push(toValue(value));
    } else {
      result[key] = [previousValue, toValue(value)];
    }
  }
  return result;
}

// node_modules/@tanstack/router-core/dist/esm/searchParams.js
var defaultParseSearch = parseSearchWith(JSON.parse);
var defaultStringifySearch = stringifySearchWith(
  JSON.stringify,
  JSON.parse
);
function parseSearchWith(parser) {
  return (searchStr) => {
    if (searchStr[0] === "?") {
      searchStr = searchStr.substring(1);
    }
    const query = decode(searchStr);
    for (const key in query) {
      const value = query[key];
      if (typeof value === "string") {
        try {
          query[key] = parser(value);
        } catch (_err) {
        }
      }
    }
    return query;
  };
}
function stringifySearchWith(stringify, parser) {
  const hasParser = typeof parser === "function";
  function stringifyValue(val) {
    if (typeof val === "object" && val !== null) {
      try {
        return stringify(val);
      } catch (_err) {
      }
    } else if (hasParser && typeof val === "string") {
      try {
        parser(val);
        return stringify(val);
      } catch (_err) {
      }
    }
    return val;
  }
  return (search) => {
    const searchStr = encode(search, stringifyValue);
    return searchStr ? `?${searchStr}` : "";
  };
}

// node_modules/@tanstack/router-core/dist/esm/redirect.js
function isRedirect(obj) {
  return obj instanceof Response && !!obj.options;
}

// node_modules/@tanstack/router-core/dist/esm/defer.js
var TSR_DEFERRED_PROMISE = Symbol.for("TSR_DEFERRED_PROMISE");

// node_modules/seroval/dist/esm/development/index.mjs
var Feature = ((Feature2) => {
  Feature2[Feature2["AggregateError"] = 1] = "AggregateError";
  Feature2[Feature2["ArrowFunction"] = 2] = "ArrowFunction";
  Feature2[Feature2["ErrorPrototypeStack"] = 4] = "ErrorPrototypeStack";
  Feature2[Feature2["ObjectAssign"] = 8] = "ObjectAssign";
  Feature2[Feature2["BigIntTypedArray"] = 16] = "BigIntTypedArray";
  return Feature2;
})(Feature || {});
var ALL_ENABLED = 1 | 2 | 4 | 8 | 16;
var REFERENCES_KEY = "__SEROVAL_REFS__";
var GLOBAL_CONTEXT_REFERENCES = "$R";
var GLOBAL_CONTEXT_R = `self.${GLOBAL_CONTEXT_REFERENCES}`;
var INV_REFERENCE = /* @__PURE__ */ new Map();
if (typeof globalThis !== "undefined") {
  Object.defineProperty(globalThis, REFERENCES_KEY, {
    value: INV_REFERENCE,
    configurable: true,
    writable: false,
    enumerable: false
  });
} else if (typeof window !== "undefined") {
  Object.defineProperty(window, REFERENCES_KEY, {
    value: INV_REFERENCE,
    configurable: true,
    writable: false,
    enumerable: false
  });
} else if (typeof self !== "undefined") {
  Object.defineProperty(self, REFERENCES_KEY, {
    value: INV_REFERENCE,
    configurable: true,
    writable: false,
    enumerable: false
  });
} else if (typeof global !== "undefined") {
  Object.defineProperty(global, REFERENCES_KEY, {
    value: INV_REFERENCE,
    configurable: true,
    writable: false,
    enumerable: false
  });
}
function createPlugin(plugin) {
  return plugin;
}
var CONSTANT_VAL = {
  [
    2
    /* True */
  ]: true,
  [
    3
    /* False */
  ]: false,
  [
    1
    /* Undefined */
  ]: void 0,
  [
    0
    /* Null */
  ]: null,
  [
    4
    /* NegZero */
  ]: -0,
  [
    5
    /* Inf */
  ]: Number.POSITIVE_INFINITY,
  [
    6
    /* NegInf */
  ]: Number.NEGATIVE_INFINITY,
  [
    7
    /* Nan */
  ]: Number.NaN
};
var NIL = void 0;
function createSerovalNode(t, i, s, l, c, m, p, e, a, f, b, o) {
  return {
    t,
    i,
    s,
    l,
    c,
    m,
    p,
    e,
    a,
    f,
    b,
    o
  };
}
function createConstantNode(value) {
  return createSerovalNode(
    2,
    NIL,
    value,
    NIL,
    NIL,
    NIL,
    NIL,
    NIL,
    NIL,
    NIL,
    NIL,
    NIL
  );
}
var TRUE_NODE = createConstantNode(
  2
  /* True */
);
var FALSE_NODE = createConstantNode(
  3
  /* False */
);
var UNDEFINED_NODE = createConstantNode(
  1
  /* Undefined */
);
var NULL_NODE = createConstantNode(
  0
  /* Null */
);
var NEG_ZERO_NODE = createConstantNode(
  4
  /* NegZero */
);
var INFINITY_NODE = createConstantNode(
  5
  /* Inf */
);
var NEG_INFINITY_NODE = createConstantNode(
  6
  /* NegInf */
);
var NAN_NODE = createConstantNode(
  7
  /* Nan */
);
var { toString: objectToString } = Object.prototype;
function createStream() {
  const listeners = /* @__PURE__ */ new Set();
  const buffer = [];
  let alive = true;
  let success = true;
  function flushNext(value) {
    for (const listener of listeners.keys()) {
      listener.next(value);
    }
  }
  function flushThrow(value) {
    for (const listener of listeners.keys()) {
      listener.throw(value);
    }
  }
  function flushReturn(value) {
    for (const listener of listeners.keys()) {
      listener.return(value);
    }
  }
  return {
    __SEROVAL_STREAM__: true,
    on(listener) {
      if (alive) {
        listeners.add(listener);
      }
      for (let i = 0, len = buffer.length; i < len; i++) {
        const value = buffer[i];
        if (i === len - 1 && !alive) {
          if (success) {
            listener.return(value);
          } else {
            listener.throw(value);
          }
        } else {
          listener.next(value);
        }
      }
      return () => {
        if (alive) {
          listeners.delete(listener);
        }
      };
    },
    next(value) {
      if (alive) {
        buffer.push(value);
        flushNext(value);
      }
    },
    throw(value) {
      if (alive) {
        buffer.push(value);
        flushThrow(value);
        alive = false;
        success = false;
        listeners.clear();
      }
    },
    return(value) {
      if (alive) {
        buffer.push(value);
        flushReturn(value);
        alive = false;
        success = true;
        listeners.clear();
      }
    }
  };
}
var REF_START_CHARS = "hjkmoquxzABCDEFGHIJKLNPQRTUVWXYZ$_";
var REF_START_CHARS_LEN = REF_START_CHARS.length;
var REF_CHARS = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789$_";
var REF_CHARS_LEN = REF_CHARS.length;

// node_modules/seroval-plugins/dist/esm/development/web.mjs
function resolveAbortSignalResult(resolve) {
  resolve(this.reason);
}
function resolveAbortSignal(resolve) {
  this.addEventListener("abort", resolveAbortSignalResult.bind(this, resolve), {
    once: true
  });
}
function abortSignalToPromise(signal) {
  return new Promise(resolveAbortSignal.bind(signal));
}
var AbortSignalController = class {
  constructor() {
    this.controller = new AbortController();
  }
};
var AbortSignalControllerPlugin = createPlugin({
  tag: "seroval-plugins/web/AbortSignalController",
  test(value) {
    return value instanceof AbortSignalController;
  },
  parse: {
    stream() {
      return void 0;
    }
  },
  serialize(_node) {
    return "new AbortController";
  },
  deserialize(_node) {
    return new AbortSignalController();
  }
});
var AbortSignalAbort = class {
  constructor(controller, reason) {
    this.controller = controller;
    this.reason = reason;
  }
};
var AbortSignalAbortPlugin = createPlugin({
  extends: [AbortSignalControllerPlugin],
  tag: "seroval-plugins/web/AbortSignalAbort",
  test(value) {
    return value instanceof AbortSignalAbort;
  },
  parse: {
    stream(value, ctx) {
      return {
        controller: ctx.parse(value.controller),
        reason: ctx.parse(value.reason)
      };
    }
  },
  serialize(node, ctx) {
    return ctx.serialize(node.controller) + ".abort(" + ctx.serialize(node.reason) + ")";
  },
  deserialize(node, ctx) {
    const controller = ctx.deserialize(
      node.controller
    );
    const reason = ctx.deserialize(node.reason);
    controller.controller.abort(reason);
    return new AbortSignalAbort(controller, reason);
  }
});
var AbortSignalPlugin = createPlugin({
  tag: "seroval-plugins/web/AbortSignal",
  extends: [AbortSignalAbortPlugin],
  test(value) {
    if (typeof AbortSignal === "undefined") {
      return false;
    }
    return value instanceof AbortSignal;
  },
  parse: {
    sync(value, ctx) {
      if (value.aborted) {
        return {
          type: 1,
          reason: ctx.parse(value.reason)
        };
      }
      return {
        type: 0
        /* Pending */
      };
    },
    async async(value, ctx) {
      if (value.aborted) {
        return {
          type: 1,
          reason: await ctx.parse(value.reason)
        };
      }
      const result = await abortSignalToPromise(value);
      return {
        type: 1,
        reason: await ctx.parse(result)
      };
    },
    stream(value, ctx) {
      if (value.aborted) {
        return {
          type: 1,
          reason: ctx.parse(value.reason)
        };
      }
      const controller = new AbortSignalController();
      ctx.pushPendingState();
      value.addEventListener(
        "abort",
        () => {
          const result = ctx.parseWithError(
            new AbortSignalAbort(controller, value.reason)
          );
          if (result) {
            ctx.onParse(result);
          }
          ctx.popPendingState();
        },
        { once: true }
      );
      return {
        type: 2,
        controller: ctx.parse(controller)
      };
    }
  },
  serialize(node, ctx) {
    if (node.type === 0) {
      return "(new AbortController).signal";
    }
    if (node.type === 1) {
      return "AbortSignal.abort(" + ctx.serialize(node.reason) + ")";
    }
    return "(" + ctx.serialize(node.controller) + ").signal";
  },
  deserialize(node, ctx) {
    if (node.type === 0) {
      const controller2 = new AbortController();
      return controller2.signal;
    }
    if (node.type === 1) {
      return AbortSignal.abort(ctx.deserialize(node.reason));
    }
    const controller = ctx.deserialize(
      node.controller
    );
    return controller.controller.signal;
  }
});
var BlobPlugin = createPlugin({
  tag: "seroval-plugins/web/Blob",
  test(value) {
    if (typeof Blob === "undefined") {
      return false;
    }
    return value instanceof Blob;
  },
  parse: {
    async async(value, ctx) {
      return {
        type: await ctx.parse(value.type),
        buffer: await ctx.parse(await value.arrayBuffer())
      };
    }
  },
  serialize(node, ctx) {
    return "new Blob([" + ctx.serialize(node.buffer) + "],{type:" + ctx.serialize(node.type) + "})";
  },
  deserialize(node, ctx) {
    return new Blob([ctx.deserialize(node.buffer)], {
      type: ctx.deserialize(node.type)
    });
  }
});
function createCustomEventOptions(current) {
  return {
    detail: current.detail,
    bubbles: current.bubbles,
    cancelable: current.cancelable,
    composed: current.composed
  };
}
var CustomEventPlugin = createPlugin({
  tag: "seroval-plugins/web/CustomEvent",
  test(value) {
    if (typeof CustomEvent === "undefined") {
      return false;
    }
    return value instanceof CustomEvent;
  },
  parse: {
    sync(value, ctx) {
      return {
        type: ctx.parse(value.type),
        options: ctx.parse(createCustomEventOptions(value))
      };
    },
    async async(value, ctx) {
      return {
        type: await ctx.parse(value.type),
        options: await ctx.parse(createCustomEventOptions(value))
      };
    },
    stream(value, ctx) {
      return {
        type: ctx.parse(value.type),
        options: ctx.parse(createCustomEventOptions(value))
      };
    }
  },
  serialize(node, ctx) {
    return "new CustomEvent(" + ctx.serialize(node.type) + "," + ctx.serialize(node.options) + ")";
  },
  deserialize(node, ctx) {
    return new CustomEvent(
      ctx.deserialize(node.type),
      ctx.deserialize(node.options)
    );
  }
});
var DOMExceptionPlugin = createPlugin({
  tag: "seroval-plugins/web/DOMException",
  test(value) {
    if (typeof DOMException === "undefined") {
      return false;
    }
    return value instanceof DOMException;
  },
  parse: {
    sync(value, ctx) {
      return {
        name: ctx.parse(value.name),
        message: ctx.parse(value.message)
      };
    },
    async async(value, ctx) {
      return {
        name: await ctx.parse(value.name),
        message: await ctx.parse(value.message)
      };
    },
    stream(value, ctx) {
      return {
        name: ctx.parse(value.name),
        message: ctx.parse(value.message)
      };
    }
  },
  serialize(node, ctx) {
    return "new DOMException(" + ctx.serialize(node.message) + "," + ctx.serialize(node.name) + ")";
  },
  deserialize(node, ctx) {
    return new DOMException(
      ctx.deserialize(node.message),
      ctx.deserialize(node.name)
    );
  }
});
function createEventOptions(current) {
  return {
    bubbles: current.bubbles,
    cancelable: current.cancelable,
    composed: current.composed
  };
}
var EventPlugin = createPlugin({
  tag: "seroval-plugins/web/Event",
  test(value) {
    if (typeof Event === "undefined") {
      return false;
    }
    return value instanceof Event;
  },
  parse: {
    sync(value, ctx) {
      return {
        type: ctx.parse(value.type),
        options: ctx.parse(createEventOptions(value))
      };
    },
    async async(value, ctx) {
      return {
        type: await ctx.parse(value.type),
        options: await ctx.parse(createEventOptions(value))
      };
    },
    stream(value, ctx) {
      return {
        type: ctx.parse(value.type),
        options: ctx.parse(createEventOptions(value))
      };
    }
  },
  serialize(node, ctx) {
    return "new Event(" + ctx.serialize(node.type) + "," + ctx.serialize(node.options) + ")";
  },
  deserialize(node, ctx) {
    return new Event(
      ctx.deserialize(node.type),
      ctx.deserialize(node.options)
    );
  }
});
var FilePlugin = createPlugin({
  tag: "seroval-plugins/web/File",
  test(value) {
    if (typeof File === "undefined") {
      return false;
    }
    return value instanceof File;
  },
  parse: {
    async async(value, ctx) {
      return {
        name: await ctx.parse(value.name),
        options: await ctx.parse({
          type: value.type,
          lastModified: value.lastModified
        }),
        buffer: await ctx.parse(await value.arrayBuffer())
      };
    }
  },
  serialize(node, ctx) {
    return "new File([" + ctx.serialize(node.buffer) + "]," + ctx.serialize(node.name) + "," + ctx.serialize(node.options) + ")";
  },
  deserialize(node, ctx) {
    return new File(
      [ctx.deserialize(node.buffer)],
      ctx.deserialize(node.name),
      ctx.deserialize(node.options)
    );
  }
});
var file_default = FilePlugin;
function convertFormData(instance) {
  const items = [];
  instance.forEach((value, key) => {
    items.push([key, value]);
  });
  return items;
}
var FORM_DATA_FACTORY = {};
var FormDataFactoryPlugin = createPlugin({
  tag: "seroval-plugins/web/FormDataFactory",
  test(value) {
    return value === FORM_DATA_FACTORY;
  },
  parse: {
    sync() {
      return void 0;
    },
    async async() {
      return await Promise.resolve(void 0);
    },
    stream() {
      return void 0;
    }
  },
  serialize(_node, ctx) {
    return ctx.createEffectfulFunction(
      ["e", "f", "i", "s", "t"],
      "f=new FormData;for(i=0,s=e.length;i<s;i++)f.append((t=e[i])[0],t[1]);return f"
    );
  },
  deserialize() {
    return FORM_DATA_FACTORY;
  }
});
var FormDataPlugin = createPlugin({
  tag: "seroval-plugins/web/FormData",
  extends: [file_default, FormDataFactoryPlugin],
  test(value) {
    if (typeof FormData === "undefined") {
      return false;
    }
    return value instanceof FormData;
  },
  parse: {
    sync(value, ctx) {
      return {
        factory: ctx.parse(FORM_DATA_FACTORY),
        entries: ctx.parse(convertFormData(value))
      };
    },
    async async(value, ctx) {
      return {
        factory: await ctx.parse(FORM_DATA_FACTORY),
        entries: await ctx.parse(convertFormData(value))
      };
    },
    stream(value, ctx) {
      return {
        factory: ctx.parse(FORM_DATA_FACTORY),
        entries: ctx.parse(convertFormData(value))
      };
    }
  },
  serialize(node, ctx) {
    return "(" + ctx.serialize(node.factory) + ")(" + ctx.serialize(node.entries) + ")";
  },
  deserialize(node, ctx) {
    const instance = new FormData();
    const entries = ctx.deserialize(node.entries);
    for (let i = 0, len = entries.length; i < len; i++) {
      const entry = entries[i];
      instance.append(entry[0], entry[1]);
    }
    return instance;
  }
});
function convertHeaders(instance) {
  const items = [];
  instance.forEach((value, key) => {
    items.push([key, value]);
  });
  return items;
}
var HeadersPlugin = createPlugin({
  tag: "seroval-plugins/web/Headers",
  test(value) {
    if (typeof Headers === "undefined") {
      return false;
    }
    return value instanceof Headers;
  },
  parse: {
    sync(value, ctx) {
      return ctx.parse(convertHeaders(value));
    },
    async async(value, ctx) {
      return await ctx.parse(convertHeaders(value));
    },
    stream(value, ctx) {
      return ctx.parse(convertHeaders(value));
    }
  },
  serialize(node, ctx) {
    return "new Headers(" + ctx.serialize(node) + ")";
  },
  deserialize(node, ctx) {
    return new Headers(ctx.deserialize(node));
  }
});
var headers_default = HeadersPlugin;
var ImageDataPlugin = createPlugin({
  tag: "seroval-plugins/web/ImageData",
  test(value) {
    if (typeof ImageData === "undefined") {
      return false;
    }
    return value instanceof ImageData;
  },
  parse: {
    sync(value, ctx) {
      return {
        data: ctx.parse(value.data),
        width: ctx.parse(value.width),
        height: ctx.parse(value.height),
        options: ctx.parse({
          colorSpace: value.colorSpace
        })
      };
    },
    async async(value, ctx) {
      return {
        data: await ctx.parse(value.data),
        width: await ctx.parse(value.width),
        height: await ctx.parse(value.height),
        options: await ctx.parse({
          colorSpace: value.colorSpace
        })
      };
    },
    stream(value, ctx) {
      return {
        data: ctx.parse(value.data),
        width: ctx.parse(value.width),
        height: ctx.parse(value.height),
        options: ctx.parse({
          colorSpace: value.colorSpace
        })
      };
    }
  },
  serialize(node, ctx) {
    return "new ImageData(" + ctx.serialize(node.data) + "," + ctx.serialize(node.width) + "," + ctx.serialize(node.height) + "," + ctx.serialize(node.options) + ")";
  },
  deserialize(node, ctx) {
    return new ImageData(
      ctx.deserialize(node.data),
      ctx.deserialize(node.width),
      ctx.deserialize(node.height),
      ctx.deserialize(node.options)
    );
  }
});
var READABLE_STREAM_FACTORY = {};
var ReadableStreamFactoryPlugin = createPlugin({
  tag: "seroval-plugins/web/ReadableStreamFactory",
  test(value) {
    return value === READABLE_STREAM_FACTORY;
  },
  parse: {
    sync() {
      return void 0;
    },
    async async() {
      return await Promise.resolve(void 0);
    },
    stream() {
      return void 0;
    }
  },
  serialize(_node, ctx) {
    return ctx.createFunction(
      ["d"],
      "new ReadableStream({start:" + ctx.createEffectfulFunction(
        ["c"],
        "d.on({next:" + ctx.createEffectfulFunction(["v"], "try{c.enqueue(v)}catch{}") + ",throw:" + ctx.createEffectfulFunction(["v"], "c.error(v)") + ",return:" + ctx.createEffectfulFunction([], "try{c.close()}catch{}") + "})"
      ) + "})"
    );
  },
  deserialize() {
    return READABLE_STREAM_FACTORY;
  }
});
function toStream(value) {
  const stream = createStream();
  const reader = value.getReader();
  async function push() {
    try {
      const result = await reader.read();
      if (result.done) {
        stream.return(result.value);
      } else {
        stream.next(result.value);
        await push();
      }
    } catch (error) {
      stream.throw(error);
    }
  }
  push().catch(() => {
  });
  return stream;
}
var ReadableStreamPlugin = createPlugin({
  tag: "seroval/plugins/web/ReadableStream",
  extends: [ReadableStreamFactoryPlugin],
  test(value) {
    if (typeof ReadableStream === "undefined") {
      return false;
    }
    return value instanceof ReadableStream;
  },
  parse: {
    sync(_value, ctx) {
      return {
        factory: ctx.parse(READABLE_STREAM_FACTORY),
        stream: ctx.parse(createStream())
      };
    },
    async async(value, ctx) {
      return {
        factory: await ctx.parse(READABLE_STREAM_FACTORY),
        stream: await ctx.parse(toStream(value))
      };
    },
    stream(value, ctx) {
      return {
        factory: ctx.parse(READABLE_STREAM_FACTORY),
        stream: ctx.parse(toStream(value))
      };
    }
  },
  serialize(node, ctx) {
    return "(" + ctx.serialize(node.factory) + ")(" + ctx.serialize(node.stream) + ")";
  },
  deserialize(node, ctx) {
    const stream = ctx.deserialize(node.stream);
    return new ReadableStream({
      start(controller) {
        stream.on({
          next(value) {
            try {
              controller.enqueue(value);
            } catch (e) {
            }
          },
          throw(value) {
            controller.error(value);
          },
          return() {
            try {
              controller.close();
            } catch (e) {
            }
          }
        });
      }
    });
  }
});
var readable_stream_default = ReadableStreamPlugin;
function createRequestOptions(current, body) {
  return {
    body,
    cache: current.cache,
    credentials: current.credentials,
    headers: current.headers,
    integrity: current.integrity,
    keepalive: current.keepalive,
    method: current.method,
    mode: current.mode,
    redirect: current.redirect,
    referrer: current.referrer,
    referrerPolicy: current.referrerPolicy
  };
}
var RequestPlugin = createPlugin({
  tag: "seroval-plugins/web/Request",
  extends: [readable_stream_default, headers_default],
  test(value) {
    if (typeof Request === "undefined") {
      return false;
    }
    return value instanceof Request;
  },
  parse: {
    async async(value, ctx) {
      return {
        url: await ctx.parse(value.url),
        options: await ctx.parse(
          createRequestOptions(
            value,
            value.body ? await value.clone().arrayBuffer() : null
          )
        )
      };
    },
    stream(value, ctx) {
      return {
        url: ctx.parse(value.url),
        options: ctx.parse(createRequestOptions(value, value.clone().body))
      };
    }
  },
  serialize(node, ctx) {
    return "new Request(" + ctx.serialize(node.url) + "," + ctx.serialize(node.options) + ")";
  },
  deserialize(node, ctx) {
    return new Request(
      ctx.deserialize(node.url),
      ctx.deserialize(node.options)
    );
  }
});
function createResponseOptions(current) {
  return {
    headers: current.headers,
    status: current.status,
    statusText: current.statusText
  };
}
var ResponsePlugin = createPlugin({
  tag: "seroval-plugins/web/Response",
  extends: [readable_stream_default, headers_default],
  test(value) {
    if (typeof Response === "undefined") {
      return false;
    }
    return value instanceof Response;
  },
  parse: {
    async async(value, ctx) {
      return {
        body: await ctx.parse(
          value.body ? await value.clone().arrayBuffer() : null
        ),
        options: await ctx.parse(createResponseOptions(value))
      };
    },
    stream(value, ctx) {
      return {
        body: ctx.parse(value.clone().body),
        options: ctx.parse(createResponseOptions(value))
      };
    }
  },
  serialize(node, ctx) {
    return "new Response(" + ctx.serialize(node.body) + "," + ctx.serialize(node.options) + ")";
  },
  deserialize(node, ctx) {
    return new Response(
      ctx.deserialize(node.body),
      ctx.deserialize(node.options)
    );
  }
});
var URLPlugin = createPlugin({
  tag: "seroval-plugins/web/URL",
  test(value) {
    if (typeof URL === "undefined") {
      return false;
    }
    return value instanceof URL;
  },
  parse: {
    sync(value, ctx) {
      return ctx.parse(value.href);
    },
    async async(value, ctx) {
      return await ctx.parse(value.href);
    },
    stream(value, ctx) {
      return ctx.parse(value.href);
    }
  },
  serialize(node, ctx) {
    return "new URL(" + ctx.serialize(node) + ")";
  },
  deserialize(node, ctx) {
    return new URL(ctx.deserialize(node));
  }
});
var URLSearchParamsPlugin = createPlugin({
  tag: "seroval-plugins/web/URLSearchParams",
  test(value) {
    if (typeof URLSearchParams === "undefined") {
      return false;
    }
    return value instanceof URLSearchParams;
  },
  parse: {
    sync(value, ctx) {
      return ctx.parse(value.toString());
    },
    async async(value, ctx) {
      return await ctx.parse(value.toString());
    },
    stream(value, ctx) {
      return ctx.parse(value.toString());
    }
  },
  serialize(node, ctx) {
    return "new URLSearchParams(" + ctx.serialize(node) + ")";
  },
  deserialize(node, ctx) {
    return new URLSearchParams(ctx.deserialize(node));
  }
});

// node_modules/@tanstack/router-core/dist/esm/ssr/serializer/ShallowErrorPlugin.js
var ShallowErrorPlugin = createPlugin({
  tag: "$TSR/Error",
  test(value) {
    return value instanceof Error;
  },
  parse: {
    sync(value, ctx) {
      return {
        message: ctx.parse(value.message)
      };
    },
    async async(value, ctx) {
      return {
        message: await ctx.parse(value.message)
      };
    },
    stream(value, ctx) {
      return {
        message: ctx.parse(value.message)
      };
    }
  },
  serialize(node, ctx) {
    return "new Error(" + ctx.serialize(node.message) + ")";
  },
  deserialize(node, ctx) {
    return new Error(ctx.deserialize(node.message));
  }
});

// node_modules/@tanstack/router-ssr-query-core/dist/esm/index.js
function setupCoreRouterSsrQueryIntegration({
  router,
  queryClient,
  handleRedirects = true
}) {
  const ogHydrate = router.options.hydrate;
  const ogDehydrate = router.options.dehydrate;
  if (router.isServer) {
    const sentQueries = /* @__PURE__ */ new Set();
    const queryStream = createPushableStream();
    router.options.dehydrate = async () => {
      router.serverSsr.onRenderFinished(() => queryStream.close());
      const ogDehydrated = await ogDehydrate?.();
      const dehydratedRouter = {
        ...ogDehydrated,
        // prepare the stream for queries coming up during rendering
        queryStream: queryStream.stream
      };
      const dehydratedQueryClient = dehydrate(queryClient);
      if (dehydratedQueryClient.queries.length > 0) {
        dehydratedQueryClient.queries.forEach((query) => {
          sentQueries.add(query.queryHash);
        });
        dehydratedRouter.dehydratedQueryClient = dehydratedQueryClient;
      }
      return dehydratedRouter;
    };
    const ogClientOptions = queryClient.getDefaultOptions();
    queryClient.setDefaultOptions({
      ...ogClientOptions,
      dehydrate: {
        shouldDehydrateQuery: () => true,
        ...ogClientOptions.dehydrate
      }
    });
    queryClient.getQueryCache().subscribe((event) => {
      if (!router.serverSsr?.isDehydrated()) {
        return;
      }
      if (sentQueries.has(event.query.queryHash)) {
        return;
      }
      if (!event.query.promise) {
        return;
      }
      if (queryStream.isClosed()) {
        console.warn(
          `tried to stream query ${event.query.queryHash} after stream was already closed`
        );
        return;
      }
      sentQueries.add(event.query.queryHash);
      queryStream.enqueue(
        dehydrate(queryClient, {
          shouldDehydrateQuery: (query) => {
            if (query.queryHash === event.query.queryHash) {
              return ogClientOptions.dehydrate?.shouldDehydrateQuery?.(query) ?? true;
            }
            return false;
          }
        })
      );
    });
  } else {
    router.options.hydrate = async (dehydrated) => {
      await ogHydrate?.(dehydrated);
      if (dehydrated.dehydratedQueryClient) {
        hydrate(queryClient, dehydrated.dehydratedQueryClient);
      }
      const reader = dehydrated.queryStream.getReader();
      reader.read().then(async function handle({ done, value }) {
        hydrate(queryClient, value);
        if (done) {
          return;
        }
        const result = await reader.read();
        return handle(result);
      }).catch((err) => {
        console.error("Error reading query stream:", err);
      });
    };
    if (handleRedirects) {
      const ogMutationCacheConfig = queryClient.getMutationCache().config;
      queryClient.getMutationCache().config = {
        ...ogMutationCacheConfig,
        onError: (error, ...rest) => {
          if (isRedirect(error)) {
            error.options._fromLocation = router.state.location;
            return router.navigate(router.resolveRedirect(error).options);
          }
          return ogMutationCacheConfig.onError?.(error, ...rest);
        }
      };
      const ogQueryCacheConfig = queryClient.getQueryCache().config;
      queryClient.getQueryCache().config = {
        ...ogQueryCacheConfig,
        onError: (error, ...rest) => {
          if (isRedirect(error)) {
            error.options._fromLocation = router.state.location;
            return router.navigate(router.resolveRedirect(error).options);
          }
          return ogQueryCacheConfig.onError?.(error, ...rest);
        }
      };
    }
  }
}
function createPushableStream() {
  let controllerRef;
  const stream = new ReadableStream({
    start(controller) {
      controllerRef = controller;
    }
  });
  let _isClosed = false;
  return {
    stream,
    enqueue: (chunk) => controllerRef.enqueue(chunk),
    close: () => {
      controllerRef.close();
      _isClosed = true;
    },
    isClosed: () => _isClosed,
    error: (err) => controllerRef.error(err)
  };
}

// node_modules/@tanstack/react-router-ssr-query/dist/esm/index.js
function setupRouterSsrQueryIntegration(opts) {
  setupCoreRouterSsrQueryIntegration(opts);
  if (opts.wrapQueryClient === false) {
    return;
  }
  const OGWrap = opts.router.options.Wrap || import_react.Fragment;
  opts.router.options.Wrap = ({ children }) => {
    return (0, import_jsx_runtime.jsx)(QueryClientProvider, { client: opts.queryClient, children: (0, import_jsx_runtime.jsx)(OGWrap, { children }) });
  };
}
export {
  setupRouterSsrQueryIntegration
};
//# sourceMappingURL=@tanstack_react-router-ssr-query.js.map
